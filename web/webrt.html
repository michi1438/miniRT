<!DOCTYPE html>
<html lang="en"><head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>webrt</title>
</head>
<body>

	<canvas style="border: solid" id="canvas"></canvas>
	<p id="coords">Coordinates: (-1 ; -1)</p>

	<input type="checkbox" id="animationToggleCheckbox" onchange="toggleAnimation(this)">
	<label for="animationToggle">Toggle Animation</label>

	<br>
	<br>
	<button onclick="raytrace();">Raytrace</button>
	<br>
	<input type="number" id="rt_precision" name="quantity" min="0.0001" max="10" value="0.003">

<script>
	/* Useful ressources */

	/* Collsion code is based on the following site: */
	/* https://hugi.scene.org/online/hugi24/coding%20graphics%20chris%20dragan%20raytracing%20shapes.htm */
	/* Archive: */
	/* https://archive.md/LvRi6 */

	/* https://iquilezles.org/articles/intersectors/ */
	/* Archive: */
	/* https://archive.md/OlpOC */

	/* Intersect SegmentCylinder page 197 (Real time collision detection by Christer Ericson) */
	/* http://www.r-5.org/files/books/computers/algo-list/realtime-3d/Christer_Ericson-Real-Time_Collision_Detection-EN.pdf */
</script>

<script>
	/* Images */
	class RtImage {
		constructor(src, target_width = 0) {
			this.img = new Image();
			this.img.src = src;
			this.target_width = target_width;
			if (this.target_width == 0) {
				this.target_width = this.img.width;
			}
			this.pixels;
			this.img.parentRtImage = this;
			this.img.onload = function () {
				this.parentRtImage.pixels = get_pixels_from_image(this.parentRtImage.img, this.parentRtImage.target_width);
			}
		}
	}

	class V4 {
	  constructor(x, y, z, a) {
		this.x = x;
		this.y = y;
		this.z = z;
		this.a = a;
	  }

	  toString() {
			return ('[' + this.x.toFixed(3) + ', ' + this.y.toFixed(3) + ', ' + this.z.toFixed(3)+ ', ' + this.a.toFixed(3) + ']')
		}
	}

	function v4(x = 0, y = 0, z = 0, a = 0) {
		return (new V4(x, y, z, a));
	}

	function new_image_height(img, new_width) {
		return (img.height / (img.width / new_width));
	}
	
	function get_pixels_from_image(imgElement, target_width) {
		// Create a canvas element
		let canvas = document.createElement('canvas');
		let context = canvas.getContext('2d');

		target_width = Math.trunc(target_width);
		// Set the canvas dimensions to match the image
		let target_height = Math.trunc(new_image_height(imgElement, target_width)) + 1;
		canvas.width = target_width;
		canvas.height = target_height;

		// Draw the image onto the canvas
		context.drawImage(imgElement, 0, 0, target_width, target_height);

		// Get the pixel data from the canvas
		let imageData = context.getImageData(0, 0, canvas.width, canvas.height).data;
		//let pixels = imageData.data;

		//pixels.push(v4(imageData[i + 0], imageData[i + 1], imageData[i + 2], imageData[i + 3]));

		let pixels = [];
		let j = -1;
		for (var i = 0; i < imageData.length; i += 4) {
			if (i % (target_width * 4) == 0) {
				j ++;
				pixels.push([]);
			}
			pixels[j].push(v4(imageData[i + 0], imageData[i + 1], imageData[i + 2], imageData[i + 3]));
		}
		/*for (var i = 0; i < imgElement.height; i++) {
			pixels.push([]);
			for (var j = 0; j < imgElement.width; j ++) {
				let adv = (i * imgElement.height) * 4 + j * 4;
				pixels[i].push(v4(imageData[adv + 0], imageData[adv + 1], imageData[adv + 2], imageData[adv + 3]));
			}
		}*/

		return (pixels);
	}

	var sun_image =  new Image();
	sun_image.src = 'sun.png';
	
</script>

<script src="test_image.js"></script>

<script>
	function clamp(val, min, max) {
		return (Math.min(Math.max(val, min), max));
	}

	/* colors */
	function add_colors(c1, c2) {
		let res = v3_add(c1, c2);
		res.x = clamp(res.x, 0, 255);
		res.y = clamp(res.y, 0, 255);
		res.z = clamp(res.z, 0, 255);
		return (res);
	}

	function mult_colors(c1, c2) {
		let res = v3(c1.x * c2.x, c1.y * c2.y, c1.z * c2.z);
		//res.x = clamp(res.x, 0, 255);
		//res.y = clamp(res.y, 0, 255);
		//res.z = clamp(res.z, 0, 255);
		return (res);
	}

	function modify_color_intensity(color, scalar) {
		let res = v3_scale(color, scalar);
		res.x = clamp(res.x, 0, 255);
		res.y = clamp(res.y, 0, 255);
		res.z = clamp(res.z, 0, 255);
		return (res);
	}

	/* Takes an intensity from 0 to 1 and returns a corresponding v3 white light color */
	function intensity_to_color(intensity) {
		let mult = 1 * clamp(intensity, 0, 1);
		return (v3(255 * mult, 255 * mult, 255 * mult));
	}
	
</script>

<script>
	function debug(arg) {
		console.log(`${arg}`);
	}
	function same_sign(a, b) {
		return ((a >= 0 && b >= 0) || (a <= 0 && b <= 0));
	}

	const Direction = {
		Forward: 0,
		Backward: 1,
		Left: 2,
		Right: 3,
		Up: 4,
		Down: 5
	}

	const ObjectType = {
		Plane: 0,
		Sphere: 1,
		Cube: 2,
		Pyramid: 3,
		Cylinder: 4
	}

	class V3 {
	  constructor(x, y, z) {
		this.x = x;
		this.y = y;
		this.z = z;
	  }

	  toString() {
			return ('[' + this.x.toFixed(3) + ', ' + this.y.toFixed(3) + ', ' + this.z.toFixed(3) + ']')
		}
	}

	class Plane {
	  constructor(p1, p2, p3) {
		this.p1 = p1;
		this.p2 = p2;
		this.p3 = p3;
	  }

	  getNormal() {
		return(v3_norm(v3_cross(v3_sub(this.p2, this.p1), v3_sub(this.p3, this.p1))));
	  }
	}

	function colinear_check(v1, v2) {
		let cross = v3_cross(v1, v2);
		return (equals_with_tolerance(v1.x, 0) && equals_with_tolerance(v1.y, 0) && equals_with_tolerance(v1.z, 0));
	}

	function plane_from_normal(point, normal) {
		/*let temp = v3(1);
		if (colinear_check(temp, normal)) {
			temp = v3(0, 1);
		}	
		let v1 = v3_cross(temp, normal);
		let v2 = v3_cross(v1, normal);
		return (new Plane(point, v3_add(point, v1), v3_add(point, v2)));*/

		/* https://math.stackexchange.com/a/64528 */
		let w;
		if (Math.abs(normal.x) <= Math.abs(normal.y) && Math.abs(normal.x) <= Math.abs(normal.z)) {
			w = v3(1);
		} else if (Math.abs(normal.y) <= Math.abs(normal.x) && Math.abs(normal.y) <= Math.abs(normal.z)) {
			w = v3(0, 1);
		} else {
			w = v3(0, 0, 1);
		}
		let u = v3_cross(w, normal);
		let v = v3_cross(normal, u);
		let p1 = v3_add(point, u);
		let p2 = v3_add(point, v);
		return (new Plane(point, p1, p2));
	}

	class Line {
		constructor(p1, p2) {
			this.p1 = p1;
			this.p2 = p2;
		}
	}

	/* v1, v2, and v3 are COLUMNS */
	class Matrix3d {
		constructor(v1, v2, v3) {
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;
		}

		toString() {
			return ('[' + this.v1 + ', ' + this.v2 + ', ' + this.v3 + ']')
		}
	}

	function same_side_of_line(line, A, B) {
		let cross1 = v3_cross(v3_sub(line.p2, line.p1), v3_sub(A, line.p1));
		let cross2 = v3_cross(v3_sub(line.p2, line.p1), v3_sub(B, line.p1));
		return (v3_dot(cross1, cross2) >= 0);
	}

	function same_side_of_plane(plane, A, B) {
		let dot1 = v3_dot(plane.getNormal(), v3_sub(A, plane.p1));
		let dot2 = v3_dot(plane.getNormal(), v3_sub(B, plane.p1));
		return (same_sign(dot1, dot2));
	}

	/* rotate point p, by a vector v, around a point r */
	function rotate_point(p, v, r) {
		let rot_matrix_x = new Matrix3d(
			v3(1, 0, 0),
			v3(0, Math.cos(v.x), Math.sin(v.x)),
			v3(0, -Math.sin(v.x), Math.cos(v.x))
			);

		let rot_matrix_y = new Matrix3d(
			v3(Math.cos(v.y), 0, -Math.sin(v.y)),
			v3(0, 1, 0),
			v3(Math.sin(v.y), 0, Math.cos(v.y))
			);

		let rot_matrix_z = new Matrix3d(
			v3(Math.cos(v.z), Math.sin(v.z), 0),
			v3(-Math.sin(v.z), Math.cos(v.z), 0),
			v3(0, 0, 1)
			);

		/* combined rotation matrix */
		let rot_matrix = matrix_mult(rot_matrix_x, matrix_mult(rot_matrix_y, rot_matrix_z));

		/* translation of point p so r becomes the origin */
		let p_translate = v3_sub(p, r);

		let p_rotated1 = matrix_mult_vec(rot_matrix, p_translate);

		return (v3_add(p_rotated1, r));
	}

	function vect_angle(v1, v2) {
		return (Math.acos(v3_dot(v1, v2) / (v3_len(v1) * v3_len(v2))));
	}

	function express_point_in_basis(point, b1, b2, b3) {
		let matrix = new Matrix3d(b1, b2, b3); /*new Matrix3d(
			v3(b1.x, b2.x, b3.x),
			v3(b1.y, b2.y, b3.y),
			v3(b1.z, b2.z, b3.z),
			);*/
		return (matrix_mult_vec(matrix, point));
	}

	/* TOTRANSLATE */
	/* projects a point on the camera plane */
	/* returns null if the line between eye and point doesn't intersect plane or is behind screen */
	var count = 4;
	function project_point(point, camera) {
		//console.log('projecting point P' + count);
		//count --;
		//console.log(point);

		/* FRUSTUM CULLING */
		/* check for y axis */		
		if (!same_side_of_plane(new Plane(camera.eye, camera.A, camera.C), camera.B, point)) {
			return (null);
		}
		if (!same_side_of_plane(new Plane(camera.eye, camera.B, camera.getD()), camera.A, point)) {
			return (null);
		}
		/* check for x axis */
		if (!same_side_of_plane(new Plane(camera.eye, camera.C, camera.getD()), camera.A, point)) {
			return (null);
		}
		if (!same_side_of_plane(new Plane(camera.eye, camera.A, camera.B), camera.C, point)) {
			return (null);
		}

		let line = new Line(camera.eye, point);
		let canvas = camera.getCanvasPlane();
		//console.log('result:');
		//console.log(intersect(line, canvas));
		let intersection = intersect(line, canvas);
		if (intersection == null) {
			return (null);
		}
		
		return (intersection);
	}

	/* Converting degrees to radians */
	function degree_to_radian(angle) {
		return (angle * Math.PI / 180);
	}

	function expressPointInBasis(A, B, C, point) {
		// Calculate coefficients
		const denominator = (B.x - A.x) * (C.y - A.y) - (C.x - A.x) * (B.y - A.y);

		const x = ((point.x - A.x) * (C.y - A.y) - (C.x - A.x) * (point.y - A.y)) / denominator;
		const y = ((B.x - A.x) * (point.y - A.y) - (point.x - A.x) * (B.y - A.y)) / denominator;

		return { x, y };
	}

	/*
	and the screen is eye_canv_dist distant from (0, 0, 0)
	A-------------------------B
	|						  |
	|						  |
	|         (eye)           |
	|						  |
	|						  |
	C-------------------------D
	*/
	class Camera {
		constructor(eye_canv_dist, screen_width, screen_height) {
			this.canvas_width = screen_width;
			this.canvas_height = screen_height;
			this.eye = v3();
			this.A = v3(-screen_width / 2, screen_height / 2, -eye_canv_dist);
			this.B = v3(screen_width / 2, screen_height / 2, -eye_canv_dist);
			this.C = v3(-screen_width / 2, -screen_height / 2, -eye_canv_dist);
		}

		getAC() {
			return (v3_sub(this.C, this.A));
		}

		getAB() {
			return (v3_sub(this.B, this.A));
		}

		/* fourth bottom right corner */
		getD() {
			return (v3_add(this.B, this.getAC()));
		}

		getCanvasPlane() {
			return (new Plane(this.A, this.B, this.C));
		}

		getCenter() {
			let ab = this.getAB();
			let half_ab = v3_scale(ab, 0.5);
			let top_middle = v3_add(this.A, half_ab);
			let ac = this.getAC();
			let half_ac = v3_scale(ac, 0.5);
			//let left_middle = v3_add(this.A, half_ac);
			return (v3_add(top_middle, half_ac));
		}

		getNorm() {
			return (v3_norm(v3_sub(this.getCenter(), this.eye)));
		}

		rotate(direction, amount) {
			let rot_vect;
			switch (direction) {
				case Direction.Right:
					rot_vect = v3_scale(v3(0, 1), -amount); //v3_scale(v3_norm(this.getAC()), amount);
					this.A = rotate_point(this.A, rot_vect, this.eye);
					this.B = rotate_point(this.B, rot_vect, this.eye);
					this.C = rotate_point(this.C, rot_vect, this.eye);
					break;
				case Direction.Left:
					rot_vect = v3_scale(v3(0, 1), amount); //v3_scale(v3_norm(this.getAC()), -amount);
					this.A = rotate_point(this.A, rot_vect, this.eye);
					this.B = rotate_point(this.B, rot_vect, this.eye);
					this.C = rotate_point(this.C, rot_vect, this.eye);
					break;
				case Direction.Up:
					rot_vect = v3_scale(v3_norm(this.getAB()), amount);
					this.A = rotate_point(this.A, rot_vect, this.eye);
					this.B = rotate_point(this.B, rot_vect, this.eye);
					this.C = rotate_point(this.C, rot_vect, this.eye);
					break;
				case Direction.Down:
					rot_vect = v3_scale(v3_norm(this.getAB()), -amount);
					this.A = rotate_point(this.A, rot_vect, this.eye);
					this.B = rotate_point(this.B, rot_vect, this.eye);
					this.C = rotate_point(this.C, rot_vect, this.eye);
					break;
				default:
					console.log(`Invalid direction: ${dir}.`);
					return ;
			}
		}

		move(direction, amount) {
			let move_vect;
			let vct;
			
			switch (direction) {
				case Direction.Forward:
					vct = v3_sub(this.getCenter(), this.eye);
					vct.y = 0;
					vct = v3_norm(vct);
					move_vect = v3_scale(vct, amount); //v3_scale(this.getNorm(), amount);
					break;
				case Direction.Backward:
					vct = v3_norm(v3_sub(this.getCenter(), this.eye));
					vct.y = 0;
					move_vect = v3_scale(vct, -amount); //v3_scale(this.getNorm(), -amount);
					break;
				case Direction.Right:
					move_vect = v3_scale(v3_norm(this.getAB()), amount);
					break;
				case Direction.Left:
					move_vect = v3_scale(v3_norm(this.getAB()), -amount);
					break;
				case Direction.Up:
					move_vect = v3_scale(v3(0, 1), amount); //v3_scale(v3_norm(this.getAC()), -amount);
					break;
				case Direction.Down:
					move_vect = v3_scale(v3(0, 1), -amount); //v3_scale(v3_norm(this.getAC()), amount);
					break;
				default:
					console.log(`Invalid direction: ${dir}.`);
					return ;
			}
			this.eye = v3_add(move_vect, this.eye);
			this.A = v3_add(move_vect, this.A);
			this.B = v3_add(move_vect, this.B);
			this.C = v3_add(move_vect, this.C);
		}

		/* expresses a 3d point relatively to point A */
		/* x: 2.52 ; y: 0.99 */
		get_point_canvas_rel(p) {
			let AB_proj = project_point_onto_line(new Line(this.A, this.B), p);
			let AC_proj = project_point_onto_line(new Line(this.A, this.C), p);
			let A_AB_proj = v3_sub(AB_proj, this.A);
			let A_AC_proj = v3_sub(AC_proj, this.A);
			let x_mult = 1;
			let y_mult = 1;
			if (!same_side_of_line(new Line(this.A, this.B), this.C, p)) {
				y_mult = -1;
			}
			if (!same_side_of_line(new Line(this.A, this.C), this.B, p)) {
				x_mult = -1;
			}
			return (v3(v3_len(A_AB_proj) * x_mult, v3_len(A_AC_proj) * y_mult));
		}
	}

	class LightAmbient {
		constructor(color) {
			this.color = color;
		}
	}

	class LightPoint {
		constructor(color, pos) {
			this.color = color;
			this.pos = pos;
		}
	}

	class LightDirectional {
		constructor(color, direction) {
			this.color = color;
			this.direction = direction;
		}
	}

	class RtIntersection {
		constructor(pos, normal, ray, item) {
			this.pos = pos;
			this.normal = normal;
			this.ray = ray;
			this.item = item;
		}
	}

	function map_point_to_physical(camera, point, physical_width, physical_height) {
		if (point == null) {
			return (null);
		}
		let x_ratio = physical_width / camera.canvas_width;
		let y_ratio = physical_height / camera.canvas_height;

		let rel = camera.get_point_canvas_rel(point);

		//let canvas_x_ratio = point.x / camera.getAB().x;
		return (v3(rel.x * x_ratio, rel.y * y_ratio /* * -1*/));
	}

	function map_physical_to_camera(camera, point, physical_width, physical_height) {
		if (point == null) {
			return (null);
		}
		let x_ratio = camera.canvas_width / physical_width;
		let y_ratio = camera.canvas_height / physical_height;

		point.x *= x_ratio;
		point.y *= y_ratio;

		let new_x = v3_add(camera.A, v3_scale(v3_norm(camera.getAB()), point.x)).x;
		let new_y = v3_add(camera.A, v3_scale(v3_norm(camera.getAC()), point.y)).y;

		return (v3(new_x, new_y, camera.A.z));
	}

	function v3(x = 0, y = 0, z = 0) {
		return (new V3(x, y, z));
	}

	function v3_clone(v) {
		return new V3(v.x, v.y, v.z);
	}

	function v3_add(a, b) {
		return (v3(a.x + b.x, a.y + b.y, a.z + b.z));
	}

	function v3_sub(a, b) {
		return (v3(a.x - b.x, a.y - b.y, a.z - b.z));
	}

	function v3_scale(a, scale) {
		return (v3(a.x * scale, a.y * scale, a.z * scale));
	}

	function v3_invert(a) {
		return (v3_scale(a, -1))
	}

	function v3_abs(a) {
		return (v3(Math.abs(a.x), Math.abs(a.y), Math.abs(a.z)));
	}

	function v3_len(a) {
		return (Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z));
	}

	function v3_norm(v) {
		return (v3_scale(v, 1/v3_len(v)));
	}

	function v3_norm_squared(v) {
		return (v.x * v.x + v.y * v.y + v.z * v.z);
	}

	function v3_cross(a, b) {
		//return (v3(a.y * b.z - a.z * b.y, a.x * b.z - a.z * b.x, a.x * b.y - a.y * b.x));

		return (
			v3(
				a.y * b.z - a.z * b.y,
				a.z * b.x - a.x * b.z,
				a.x * b.y - a.y * b.x
				)
			);
	}

	function v3_dot(a, b) {
		return (a.x * b.x + a.y * b.y + a.z * b.z);
	}

	/* https://stackoverflow.com/a/12499474 */
	function project_point_onto_line(line, point) {
		let A = line.p1;
		let B = line.p2;
		let C = point;
		let x1 = A.x, y1 = A.y, z1 = A.z;
		let x2 = B.x, y2 = B.y, z2 = B.z;
		let x3 = C.x, y3 = C.y, z3 = C.z;
		let px = x2 - x1, py = y2 - y1, pz = z2 - z1;
		let dAB = px * px + py * py + pz * pz;
		let u = ((x3 - x1) * px + (y3 - y1) * py + (z3 - z1) * pz) / dAB;
		let x = x1 + u * px, y = y1 + u * py, z = z1 + u * pz;
		return (v3(x, y, z));
	}

	/* https://stackoverflow.com/a/3863777 */
	function point_plane_dist(point, plane) {
		return (Math.abs(v3_dot(plane.getNormal(), (v3_sub(point, plane.p1)))));
	}

	function signed_point_plane_dist(point, plane) {
		return (v3_dot(plane.getNormal(), (v3_sub(point, plane.p1))));
	}

	/* https://stackoverflow.com/a/17661431 */
	function project_point_onto_plane(point, plane) {
		let dist = signed_point_plane_dist(point, plane);
		let n = v3_scale(plane.getNormal(), dist);
		if (dist > 0) {
			/* the normal is pointing towards the point */
			return (v3_sub(point, n));
		} else {
			/* opposite case */
			return (v3_add(point, n));
		}
	}

	/* Multiplying a 3D matrix with a 3D vector (M x V) */
	function matrix_mult_vec(matrix, t_v) {
		let v1 = v3_scale(matrix.v1, t_v.x);
		let v2 = v3_scale(matrix.v2, t_v.y);
		let v3_ = v3_scale(matrix.v3, t_v.z);
		return (v3_add(v1, v3_add(v2, v3_)));
	}

	/* Multiplying each term of a 3D matrix by a scalar */
	function matrix_scale(matrix, scalar) {
		let v1 = v3_scale(matrix.v1, scalar);
		let v2 = v3_scale(matrix.v2, scalar);
		let v3_ = v3_scale(matrix.v3, scalar);
		return (new Matrix3d(v1, v2, v3_));
	}

	/* Multiplying two 3D matrices */
	function matrix_mult(m1, m2) {
		let v1 = v3(
				m1.v1.x * m2.v1.x + m1.v2.x * m2.v1.y + m1.v3.x * m2.v1.z,
				m1.v1.y * m2.v1.x + m1.v2.y * m2.v1.y + m1.v3.y * m2.v1.z,
				m1.v1.z * m2.v1.x + m1.v2.z * m2.v1.y + m1.v3.z * m2.v1.z);

		let v2 = v3(
				m1.v1.x * m2.v2.x + m1.v2.x * m2.v2.y + m1.v3.x * m2.v2.z,
				m1.v1.y * m2.v2.x + m1.v2.y * m2.v2.y + m1.v3.y * m2.v2.z,
				m1.v1.z * m2.v2.x + m1.v2.z * m2.v2.y + m1.v3.z * m2.v2.z);

		let v3_ = v3(
				m1.v1.x * m2.v3.x + m1.v2.x * m2.v3.y + m1.v3.x * m2.v3.z,
				m1.v1.y * m2.v3.x + m1.v2.y * m2.v3.y + m1.v3.y * m2.v3.z,
				m1.v1.z * m2.v3.x + m1.v2.z * m2.v3.y + m1.v3.z * m2.v3.z);
		return (new Matrix3d(v1, v2, v3_));
	}

	function matrix_sub(m1, m2) {
		let v1 = v3(m1.v1.x - m2.v1.x, m2.v1.y - m2.v1.y, m1.v1.z - m2.v1.z);
		let v2 = v3(m1.v2.x - m2.v2.x, m2.v2.y - m2.v2.y, m1.v2.z - m2.v2.z);
		let v3_ = v3(m1.v3.x - m2.v3.x, m2.v3.y - m2.v3.y, m1.v3.z - m2.v3.z);
		return (new Matrix3d(v1, v2, v3_));
	}

	function get_identity_matrix() {
		let v1 = v3(1, 0, 0);
		let v2 = v3(0, 1, 0);
		let v3_ = v3(0, 0, 1);
		return (new Matrix3d(v1, v2, v3_))
	}

	class Item {
		constructor(type, pos, scale, rot, color, specular, is_checker, image, vertex_func, draw_mapping_func, raytrace_func, line_width = 1) {
			this.type = type;
			this.pos = pos;
			this.scale = scale;
			this.rot = rot;
			if (rot.x == 0 && rot.y == 0 && rot.z == 0) {
				//this.rot = v3(0, -1);
			}
			this.color = color;
			this.specular = specular;
			this.is_checker = is_checker;
			this.image = image;
			this.vertex_func = vertex_func;
			this.draw_mapping_func = draw_mapping_func;
			this.raytrace_func = raytrace_func;
			this.z_ref_point = v3_add(v3(0, 1), this.pos);
			if (this.vertex_func) {
				this.vertices = vertex_func(pos, scale);
				rotate_item(this, this.rot);
			}
			/* https://stackoverflow.com/a/12502559 */
			this.id = Math.random().toString(36).slice(2);
			this.pixel_cache = null;
			this.cache_width = 0;
		}

		get_axis() {
			return (v3_norm(v3_sub(this.z_ref_point, this.pos)));
		}

		draw_axes() {
			let z_axis = v3_scale(this.get_axis(), 0.5);
			let plane = plane_from_normal(this.pos, z_axis);
			let y_axis = v3_scale(v3_norm(v3_sub(plane.p2, this.pos)), 0.5);
			let x_axis = v3_scale(v3_norm(v3_sub(plane.p3, this.pos)), 0.5);
			draw_segment(this.pos, v3_add(this.pos, z_axis), 'blue');
			draw_segment(this.pos, v3_add(this.pos, y_axis), 'green');
			draw_segment(this.pos, v3_add(this.pos, x_axis), 'red');
		}

		color_hex() {
			return (rgbToHex(this.color.x, this.color.y, this.color.z));
		}
	}

	function get_cylinder_top(cylinder) {
		let V = v3_norm(v3_sub(cylinder.vertices[0], cylinder.vertices[cylinder.vertices.length/2]));
		let cylinder_length = cylinder.scale.y;
		return (v3_add(cylinder.pos, v3_scale(V, -cylinder_length / 2)));
	}

	function get_cylinder_bottom(cylinder) {
		let V = v3_norm(v3_sub(cylinder.vertices[0], cylinder.vertices[cylinder.vertices.length/2]));
		let cylinder_length = cylinder.scale.y;
		return(v3_add(cylinder.pos, v3_scale(V, cylinder_length / 2)));
	}

	function intersect(line, plane) {
		let n = v3_norm(v3_cross(v3_sub(plane.p3, plane.p1), v3_sub(plane.p2, plane.p1))); /* vector normal to the plane */
		let d = -(n.x * plane.p1.x + n.y * plane.p1.y + n.z * plane.p1.z); /* distance from the plane to the origin */ /* it's negative because we want to represent the plane equation as n.x*x + n.y*y + n.z*z + d = 0 */
		let lv = v3_sub(line.p2, line.p1);

		/* plugging in the line eq into the plane eq */
		let divisor = n.x * lv.x + n.y * lv.y + n.z * lv.z;
		if (divisor == 0) {
			return (null);
		}
		let dividend = -(n.x * line.p1.x + n.y * line.p1.y + n.z * line.p1.z + d);
		if (dividend == 0) {
			return (null);
		}
		let t = dividend / divisor;
		return (v3_add(line.p1, v3_scale(lv, t)));
	}
</script>

<script>
	// axis convention: left hand. (inverted y axis on geogebra, left thumb pointing towards user)

	var htmlcanvas = document.getElementById('canvas');
	htmlcanvas.width = 1000;
	htmlcanvas.height = 1000;
	var [RED, GREEN, BLUE, YELLOW, LIGHTBLUE, BLACK, PINK, WHITE] = [v3(255, 0, 0), v3(0, 255, 0), v3(0, 0, 255), v3(255, 255, 0), v3(68, 85, 90), v3(), v3(255, 222, 251), v3(255, 255, 255)];
	var ctx = htmlcanvas.getContext('2d');
	const TOLERANCE = 0.000001;//1e-6; // how parallel a line is to the plane means parallel$
	const origin = v3();
	var canvas_dist = 1;
	var canvas_size = v3(2, 2);
	var camera = new Camera(canvas_dist, canvas_size.x, canvas_size.y);

	var debug_toggle = false;
	var mouse_grabbed = false;

	var animationToggleCheckbox = document.getElementById('animationToggleCheckbox');
	var rotate_items_toggle = animationToggleCheckbox.checked;
	var items_rotation_speed = 0.003;

	var items = [];

	function equals_with_tolerance(val1, val2) {
		return (val1 <= val2 + TOLERANCE && val1 >= val2 - TOLERANCE);
	}

	function draw_line(x1, y1, x2, y2, color = 'black', width = 2) {
		ctx.strokeStyle = color;
		ctx.lineWidth = width;
		ctx.beginPath();
		ctx.moveTo(x1, y1);
		ctx.lineTo(x2, y2);
		ctx.stroke();
	}

	function fill_canvas(color = 'white') {
		ctx.fillStyle = color;
		ctx.beginPath();
		ctx.rect(0, 0, htmlcanvas.width,  htmlcanvas.height);
		ctx.fill();
		ctx.closePath();
	}

	function draw_circle(x, y, radius, color = 'black', width = 1, full = false) {
		ctx.beginPath();
		ctx.lineWidth = width;
		ctx.strokeStyle = color;
		ctx.arc(x, y, radius, 0, 2 * Math.PI);
		if (full) {
			ctx.fill();
		}
		ctx.stroke();
		ctx.closePath();
	}

	function draw_square(x, y, size, color = 'black') {
		ctx.fillStyle = color;
		ctx.fillRect(x, y, size, size);
	}

	function draw_vect(v, color = 'black', width = 1, radius = 5) {
		if (v == null) {
			return ;
		}
		draw_square(v.x - radius / 2, v.y - radius / 2, radius, color);
		//draw_circle(v.x, v.y, radius, color, width);
	}

	/* https://stackoverflow.com/a/5624139 */
	function rgbToHex(r, g, b) {
		return ("#" + (1 << 24 | r << 16 | g << 8 | b).toString(16).slice(1));
	}
	function rgbToHexV3(v) {
		return ("#" + (1 << 24 | v.x << 16 | v.y << 8 | v.z).toString(16).slice(1));
	}
	function hexToRgb(hex) {
		// Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
		var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
		hex = hex.replace(shorthandRegex, function(m, r, g, b) {
			return r + r + g + g + b + b;
		});

		var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
		return result ? {
			r: parseInt(result[1], 16),
			g: parseInt(result[2], 16),
			b: parseInt(result[3], 16)
		} : null;
	}

	function connect_points(p1, p2, item) {
		//console.log('connecting points:');
		//console.log(p1);
		//console.log(p2);
		if (p1 == null || p2 == null) {
			return ;
		}
		draw_vect(p1, item.color_hex(), 0.3);//, '#' + point_connector_color.toString(16));
		draw_vect(p2, item.color_hex(), 0.3);//'#' + point_connector_color.toString(16));
		draw_line(p1.x, p1.y, p2.x, p2.y, item.color_hex(), item.line_width);
	}

	function draw_segment(p1, p2, color = 'lightgreen') {
		p1 = map_point_to_physical(camera, project_point(p1, camera), htmlcanvas.width, htmlcanvas.height);
		if (!p1) {
			return ;
		}
		p2 = map_point_to_physical(camera, project_point(p2, camera), htmlcanvas.width, htmlcanvas.height);
		if (!p2) {
			return ;
		}
		draw_vect(p1, color, 0.3);//, '#' + point_connector_color.toString(16));
		draw_vect(p2, color, 0.3);//'#' + point_connector_color.toString(16));
		draw_line(p1.x, p1.y, p2.x, p2.y, color, 2);
	}

	function add_item(item) {
		items.push(item);
	}

	function lerp(start, end, x) {
		return (1 - x) * start + x * end;
	}

	function smoothColorTransition(counter, maxCounter) {
		// Function to smoothly transition between colors for a cyclic counter
		const startColor = [255, 0, 0];  // Red
		const middleColor = [0, 255, 0]; // Green
		const endColor = [0, 0, 255];    // Blue

		const t = counter / maxCounter;
		if (counter <= maxCounter / 3) {
			return v3(
				Math.round(lerp(startColor[0], middleColor[0], t)),
				Math.round(lerp(startColor[1], middleColor[1], t)),
				Math.round(lerp(startColor[2], middleColor[2], t))
			);
		} else if (counter <= maxCounter / 3 * 2) {
			return v3(
				Math.round(lerp(middleColor[0], endColor[0], t)),
				Math.round(lerp(middleColor[1], endColor[1], t)),
				Math.round(lerp(middleColor[2], endColor[2], t))
			);
		} else {
			return v3(
				Math.round(lerp(endColor[0], startColor[0], t)),
				Math.round(lerp(endColor[1], startColor[1], t)),
				Math.round(lerp(endColor[2], startColor[2], t))
			);
		}
	}
	var iter = 0;
	var color_iter = 0;
	function animate() {
		if (rotate_items_toggle) {
			for (let i = 0; i < items.length; i++) {
				//scale_item(items[i], v3(0.2 + Math.sin(iter), 0.2 + Math.sin(iter), 0.2 + Math.sin(iter)));
				rotate_item(items[i], v3_scale(v3(1, 2, 4), items_rotation_speed));
				iter += 0.05;
				iter = iter % Math.PI;
				color_iter = (color_iter + 1) % 600;

				//items[i].color = smoothColorTransition(color_iter, 600);
			}
			draw();
			for (let i = 0; i < items.length; i++) {
				items[i].draw_axes();
			}
			//raytrace();
		}
	}

	function draw() {
		console.log('drawing...');
		fill_canvas('black');
		for (let i = 0; i < items.length; i++) {
			outline_item(items[i]);
		}

		/* debug overlay */
		if (debug_toggle) {
			function translate_vec(v) {
				return (v3(v.x, v.z));
			}
			draw_vect(v3_scale(v3_add(translate_vec(v3()), v3(10, 10)), 20), 'aqua');
			//canvas_dist = 100;
			
			let a = v3_scale(v3_add(translate_vec(camera.A), v3(10, 10)), 20);
			let b = v3_scale(v3_add(translate_vec(camera.B), v3(10, 10)), 20);
			let c = v3_scale(v3_add(translate_vec(camera.C), v3(10, 10)), 20);
			let d = v3_scale(v3_add(translate_vec(camera.getD()), v3(10, 10)), 20);
			let eye = v3_scale(v3_add(translate_vec(camera.eye), v3(10, 10)), 20);
			draw_vect(a, 'blue');
			draw_vect(b, 'green');
			draw_vect(c, 'orange');
			draw_vect(d, 'pink');
			draw_vect(eye, 'red');



			let ref_point_ = v3_scale(v3_add(translate_vec(v3_add(camera.getCenter(), camera.getNorm())), v3(10, 10)), 20);
			draw_vect(ref_point_, 'lightblue');

			draw_line(a.x, a.y, b.x, b.y, 'grey', 0.5);
			draw_line(b.x, b.y, d.x, d.y, 'grey', 0.5);
			draw_line(d.x, d.y, c.x, c.y, 'grey', 0.5);
			draw_line(c.x, c.y, a.x, a.y, 'grey', 0.5);

			draw_line(a.x, a.y, eye.x, eye.y, 'grey', 0.5);
			draw_line(b.x, b.y, eye.x, eye.y, 'grey', 0.5);
			draw_line(d.x, d.y, eye.x, eye.y, 'grey', 0.5);
			draw_line(c.x, c.y, eye.x, eye.y, 'grey', 0.5);

			
			for (let i = 0; i < items.length; i++) {
				for (let j = 0; j < items[i].vertices.length; j ++) {
					//if (items[i].vertices[j] == null) {
					//	continue ;
					//}
					let pt = v3_scale(v3_add(translate_vec(items[i].vertices[j]), v3(10, 10)), 20);
					//let zero = v3_scale(v3_add(translate_vec(v3()), v3(10, 10)), 20);
					let orig = v3_scale(v3_add(translate_vec(camera.eye), v3(10, 10)), 20);
					draw_vect(pt, 'blueviolet');
					draw_line(pt.x, pt.y, orig.x, orig.y, 'grey', 0.5);
				}
			}
			
			console.log('-------');
			let ab = camera.getAB();
			let ref_point = v3_add(camera.getCenter(), camera.getNorm());
			let ref_cross = v3_cross(ab, ref_point);
			let test_cross = v3_cross(ab, items[0].vertices[0]);
			console.log(ref_point);
			console.log(ref_cross);
			console.log(test_cross);
			console.log('-------');
		}

		if (mouse_grabbed) {
			draw_vect(v3(htmlcanvas.width / 2, htmlcanvas.height / 2), 'red', 1, 3);
		}
		draw_lights();
		/*for (let height = 0; height < test_image_pixels.length; height++) {
			for (let width = 0; width < test_image_pixels[height].length; width++) {
				let pixel = test_image_pixels[height][width];
				let color = rgbToHexV3(v3(pixel.x, pixel.y, pixel.z));
				draw_circle(width, height, 1, color, false);
			}
		}*/
	}

	/* returns a list of sphere vertices */
	/* scale.x: radius ; scale.y: amount of vertices around axis y ; scale.z: amount of vertices around axis z */
	function sphere_vertices(pos, scale) {
		let vertices = [];
		
		/*vertices.push(
			v3_add(
				pos,
				v3(0, scale.x / 2)
			);*/

		let top_point = v3_add(pos, v3(0, scale.x / 2));
		for (let i = 1; i <= scale.y; i ++) {
			for (let j = 1; j <= scale.z; j ++) {
				vertices.push(rotate_point(rotate_point(top_point, v3(0, 0, j * Math.PI / (scale.z + 1)), pos), v3(0, i * Math.PI / (scale.y /2), 0), pos));	
			}
		}
		vertices.push(top_point);
		let bottom_point = v3_add(pos, v3(0, -scale.x / 2));
		vertices.push(bottom_point);
		return (vertices);
	}

	/* returns a list of pyramid vertices */
	function pyramid_vertices(pos, scale) {
		let vertices = [];
		
		/*
		vertices.push(
			v3_add(
				pos,
				v3_add(
					v3(X),
					v3_add(
						v3(0, Y),
						v3(0, 0, Z)
						)
					)
				)
			);
			*/

		vertices.push( //1
			v3_add(
				pos,
				v3(0, scale.y / 2)
				)
			);

		vertices.push( //2
			v3_add(
				pos,
				v3_add(
					v3(-scale.x / 2),
					v3_add(
						v3(0, -scale.y / 2),
						v3(0, 0, -scale.z / 2)
						)
					)
				)
			);

		vertices.push( //3
			v3_add(
				pos,
				v3_add(
					v3(scale.x / 2),
					v3_add(
						v3(0, -scale.y / 2),
						v3(0, 0, -scale.z / 2)
						)
					)
				)
			);

		vertices.push( //4
			v3_add(
				pos,
				v3_add(
					v3(scale.x / 2),
					v3_add(
						v3(0, -scale.y / 2),
						v3(0, 0, scale.z / 2)
						)
					)
				)
			);

		vertices.push( //5
			v3_add(
				pos,
				v3_add(
					v3(-scale.x / 2),
					v3_add(
						v3(0, -scale.y / 2),
						v3(0, 0, scale.z / 2)
						)
					)
				)
			);

		return (vertices);
	}

	/* returns list of cube vertices */
	function cube_vertices(pos, scale) {
		let vertices = [];
		vertices.push(
			v3_add(
				pos,
				v3_add(
					v3(0, 0, scale.z / 2),
					v3_add(
						v3(0, scale.y / 2),
						v3(-scale.x / 2)
						)
					)
				)
			);
		vertices.push(
			v3_add(
				pos,
				v3_add(
					v3(0, 0, -scale.z / 2),
					v3_add(
						v3(0, scale.y / 2),
						v3(-scale.x / 2)
						)
					)
				)
			);
		vertices.push(
			v3_add(
				pos,
				v3_add(
					v3(0, 0, -scale.z / 2),
					v3_add(
						v3(0, scale.y / 2),
						v3(scale.x / 2)
						)
					)
				)
			);
		vertices.push(
			v3_add(
				pos,
				v3_add(
					v3(0, 0, scale.z / 2),
					v3_add(
						v3(0, scale.y / 2),
						v3(scale.x / 2)
						)
					)
				)
			);
		/* down vertices */
		vertices.push(
			v3_add(
				pos,
				v3_add(
					v3(0, 0, scale.z / 2),
					v3_add(
						v3(0, -scale.y / 2),
						v3(-scale.x / 2)
						)
					)
				)
			);
		vertices.push(
			v3_add(
				pos,
				v3_add(
					v3(0, 0, -scale.z / 2),
					v3_add(
						v3(0, -scale.y / 2),
						v3(-scale.x / 2)
						)
					)
				)
			);
		vertices.push(
			v3_add(
				pos,
				v3_add(
					v3(0, 0, -scale.z / 2),
					v3_add(
						v3(0, -scale.y / 2),
						v3(scale.x / 2)
						)
					)
				)
			);
		vertices.push(
			v3_add(
				pos,
				v3_add(
					v3(0, 0, scale.z / 2),
					v3_add(
						v3(0, -scale.y / 2),
						v3(scale.x / 2)
						)
					)
				)
			);
		return (vertices);
	}

	/* returns list of cube vertices */
	function cylinder_vertices(pos, scale) {
		let vertices = [];
		// pos.x = cylinder diameter
		// pos.y = cylinder height
		// pos.z = level of detail
		let top = v3_add(pos, v3(0, -scale.y / 2));
		let first = v3_add(top, v3(scale.x / 2));
		//console.log(`top: ${top}, first: ${first}`);
		for (var i = 0; i < scale.z; i++) {
			vertices.push(
				rotate_point(
					first,
					v3(0, i * Math.PI / (scale.z /2), 0),
					pos
				)
			);
		}
		let bottom = v3_add(pos, v3(0, scale.y / 2));
		let second = v3_add(bottom, v3(scale.x / 2));
		for (var i = 0; i < scale.z; i++) {
			vertices.push(
				rotate_point(
					second,
					v3(0, i * Math.PI / (scale.z /2), 0),
					pos
				)
			);
		}
		return (vertices);
	}

	function draw_cube_mappings(mappings, item) {
		connect_points(mappings[0], mappings[1], item);
		connect_points(mappings[1], mappings[2], item);
		connect_points(mappings[2], mappings[3], item);
		connect_points(mappings[3], mappings[0], item);

		connect_points(mappings[0], mappings[4], item);
		connect_points(mappings[1], mappings[5], item);
		connect_points(mappings[2], mappings[6], item);
		connect_points(mappings[3], mappings[7], item);

		connect_points(mappings[4], mappings[5], item);
		connect_points(mappings[5], mappings[6], item);
		connect_points(mappings[6], mappings[7], item);
		connect_points(mappings[7], mappings[4], item);
	}

	function draw_pyramid_mappings(mappings, item) {
		connect_points(mappings[0], mappings[1], item);
		connect_points(mappings[0], mappings[2], item);
		connect_points(mappings[0], mappings[3], item);
		connect_points(mappings[0], mappings[4], item);

		connect_points(mappings[1], mappings[2], item);
		connect_points(mappings[2], mappings[3], item);
		connect_points(mappings[3], mappings[4], item);
		connect_points(mappings[4], mappings[1], item);
	}

	function draw_sphere_mappings(mappings, item) {
		/*for (var i = 0; i < mappings.length - 1; i++) {
			connect_points(mappings[i], mappings[i + 1]);
		}*/
		let top_point = mappings[mappings.length - 2];
		let bottom_point = mappings[mappings.length - 1];
		for (let i = 0; i < item.scale.y; i++) {
			connect_points(top_point, mappings[i * item.scale.z], item);
			connect_points(bottom_point, mappings[i * item.scale.z + item.scale.z - 1], item);
			for (var j = 0; j < item.scale.z - 1; j++) {
				connect_points(mappings[i * item.scale.z + j], mappings[i * item.scale.z + j + 1], item);
			}
		}
	}

	function draw_cylinder_mappings(mappings, item) {
		for (let i = 0; i < mappings.length / 2 - 1; i++) {
			connect_points(mappings[i], mappings[i + 1], item);
		}
		connect_points(mappings[mappings.length/2 - 1], mappings[0], item);
		for (let i = mappings.length / 2; i < mappings.length- 1; i++) {
			connect_points(mappings[i], mappings[i + 1], item);
		}
		connect_points(mappings[mappings.length - 1], mappings[mappings.length/2], item);
		for (let i = 0; i < mappings.length / 2; i++) {
			connect_points(mappings[i], mappings[i + mappings.length / 2], item);
		}
	}


	function move_item(item, pos) {
		item.pos = v3_add(item.pos, pos);
		for (let i = 0; i < item.vertices.length; i++) {
			item.vertices[i] = v3_add(item.vertices[i], pos);
		}
	}

	function move_item_to(item, pos) {
		move_item(item, v3_sub(pos, item.pos));
	}

	function rotate_item(item, rot) {
		if (!item.vertex_func) {
			return ;
		}
		for (let i = 0; i < item.vertices.length; i++) {
			item.vertices[i] = rotate_point(item.vertices[i], rot, item.pos);
		}
		item.z_ref_point = rotate_point(item.z_ref_point, rot, item.pos);
		/* deprecated */
		item.rot = v3_add(item.rot, rot);
	}

	function scale_item(item, scale) {
		let rot_backup = v3(item.rot.x, item.rot.y, item.rot.z);
		rotate_item(item, v3_invert(item.rot));
		item.scale = v3(scale.x, scale.y, scale.z);
		item.vertices = item.vertex_func(item.pos, item.scale);
		rotate_item(item, rot_backup);
	}

	function outline_item(item) {
		if (!item.vertex_func) {
			return ;
		}
		let mappings = [];
		for (var i = 0; i < item.vertices.length; i++) {
			let mapping = map_point_to_physical(camera, project_point(item.vertices[i], camera), htmlcanvas.width, htmlcanvas.height);
			//console.log(`pushing mapping: ${mapping}`);
			mappings.push(mapping);
		}
		item.draw_mapping_func(mappings, item);
	}
	
	let cube = new Item(ObjectType.Cube, v3(-2, 0, -5), v3(2, 2, 2), v3(), PINK, -1, true, null, cube_vertices, draw_cube_mappings);

	let cube2 = new Item(ObjectType.Cube, v3(0, 0, -2), v3(1, 1, 1), v3(), YELLOW, -1, true, null, cube_vertices, draw_cube_mappings);

	let pyramid = new Item(ObjectType.Pyramid, v3(2, 0, -5), v3(1, 2, 1), v3(), BLUE, -1, true, null, pyramid_vertices, draw_pyramid_mappings);

	let sphere = new Item(ObjectType.Sphere, v3(0, 2, -4), v3(2, 8, 4), v3(), RED, 500, false, null, sphere_vertices, draw_sphere_mappings);

	let sphere2 = new Item(ObjectType.Sphere, v3(0, 0, -8), v3(1, 8, 4), v3(), GREEN, -1, true, null, sphere_vertices, draw_sphere_mappings);
	
	let sphere3 = new Item(ObjectType.Sphere, v3(3, 0, -5), v3(1, 8, 4), v3(), BLUE, -1, true, null, sphere_vertices, draw_sphere_mappings);

	let cylinder = new Item(ObjectType.Cylinder, v3(2,1,-3), v3(1, 2, 10), /*v3(0.5850000000000004, 1.1700000000000008, 2.3400000000000016)*/ v3(), GREEN, -1, true, null, cylinder_vertices, draw_cylinder_mappings);

	/* In the case of the plane first v3 is a point and second is normal. Third is unused. */
	let test_plane = new Item(ObjectType.Plane, v3(0, 0, -15), v3(0, 0, 1), v3(), GREEN, -1, false, null, null, null);

	let bottom_plane = new Item(ObjectType.Plane, v3(0, -15, 0), v3(0, 1, 0), v3(), YELLOW, -1, false, null, null, null);

	add_item(cube);
	//add_item(cube2);
	//add_item(pyramid);
	//add_item(sphere);
	//add_item(sphere2);
	//add_item(sphere3);
	//add_item(cylinder);
	//add_item(test_plane);
	//add_item(bottom_plane);

	var shift_pressed = false;
	var two_pressed = false;
	document.addEventListener('keydown', (event) => {
		if (event.key == 'Shift') {
			shift_pressed = true;
		}
		if (event.key == '2') {
			two_pressed = true;
		}
	});
	document.addEventListener('keyup', (event) => {
		if (event.key == 'Shift') {
			shift_pressed = false;
		}
		if (event.key == '2') {
			two_pressed = false;
		}
	});

	
	document.addEventListener('keydown', (event) => {
		if (event.key == '1') {
			draw();
		} else if (event.key == 'w') {
			camera.move(Direction.Forward, 0.1);
			draw();
		} else if (event.key == 's') {
			camera.move(Direction.Backward, 0.1);
			draw();
		} else if (event.key == 'a') {
			camera.move(Direction.Left, 0.1);
			draw();
		} else if (event.key == 'd') {
			camera.move(Direction.Right, 0.1);
			draw();
		} else if (event.key == 'Shift') {
			camera.move(Direction.Down, 0.1);
			draw();
		} else if (event.key == ' ') {
			camera.move(Direction.Up, 0.1);
			draw();
		} else if (event.key == 'ArrowRight') {
			camera.rotate(Direction.Right, 0.1);
			draw();
		} else if (event.key == 'ArrowLeft') {
			camera.rotate(Direction.Left, 0.1);
			draw();
		} else if (event.key == 'ArrowUp') {
			camera.rotate(Direction.Up, 0.1);
			draw();
		} else if (event.key == 'ArrowDown') {
			camera.rotate(Direction.Down, 0.1);
			draw();
		} else if (event.key == 'D') {
			debug_toggle = !debug_toggle;
			draw();
		} else {
			//console.log(event);
		}
	});

	document.addEventListener('DOMContentLoaded', (event) => {
		draw();
		animation_interval = setInterval(animate, 25);
	});

	
	/////////////////////////////////

	function getMousePos(canvas, evt) {
		var rect = canvas.getBoundingClientRect();
		return {
			x: evt.clientX - rect.left,
			y: evt.clientY - rect.top
		};
	}

	// when the document is loaded, setup the listeners for the two canvas elements
	document.addEventListener('DOMContentLoaded', function () {
		setupPointerLock();
	});


	// Configure all the pointer lock stuff
	function setupPointerLock() {

		// register the callback when a pointerlock event occurs
		document.addEventListener('pointerlockchange', changeCallback, false);
		document.addEventListener('mozpointerlockchange', changeCallback, false);
		document.addEventListener('webkitpointerlockchange', changeCallback, false);

		// when element is clicked, we're going to request a
		// pointerlock
		htmlcanvas.addEventListener('click', function (event) {
			if (!two_pressed) {
				var requestPointerLock = htmlcanvas.requestPointerLock || htmlcanvas.mozRequestPointerLock || htmlcanvas.webkitRequestPointerLock;

				// Ask the browser to lock the pointer
				if (requestPointerLock) {
					htmlcanvas.requestPointerLock();
				}
			} else {
				let real_pos = getMousePos(htmlcanvas, event);
				cast_ray_for_screen_coords(real_pos.x, real_pos.y);
			}
		});


	}


	// called when the pointer lock has changed. Here we check whether the
	// pointerlock was initiated on the element we want.
	function changeCallback(e) {
		if (document.pointerLockElement === htmlcanvas ||
				document.mozPointerLockElement === htmlcanvas ||
				document.webkitPointerLockElement === htmlcanvas) {

			// we've got a pointerlock for our element, add a mouselistener
			document.addEventListener("mousemove", moveCallback, false);
			mouse_grabbed = true;
		} else {

			// pointer lock is no longer active, remove the callback
			document.removeEventListener("mousemove", moveCallback, false);
			mouse_grabbed = false;
			// and reset the entry coordinates
			entryCoordinates = {x:-1, y:-1};
		}
	};


	// handles an event on the canvas for the pointerlock example
	var entryCoordinates = {x:-1, y:-1};
	function moveCallback(e) {

		// if we enter this for the first time, get the initial position
		if (entryCoordinates.x == -1) {
			entryCoordinates = getPosition(htmlcanvas, e);
		}


		//get a reference to the canvas
		var movementX = e.movementX ||
				e.mozMovementX ||
				e.webkitMovementX ||
				0;

		var movementY = e.movementY ||
				e.mozMovementY ||
				e.webkitMovementY ||
				0;


		// calculate the new coordinates where we should draw the ship
		entryCoordinates.x = entryCoordinates.x + movementX;
		entryCoordinates.y = entryCoordinates.y + movementY;

		if (entryCoordinates.x > htmlcanvas.offsetWidth -65) {
			entryCoordinates.x = htmlcanvas.offsetWidth -65;
		} else if (entryCoordinates.x < 0) {
			entryCoordinates.x = 0;
		}

		if (entryCoordinates.y > htmlcanvas.offsetHeight - 85) {
			entryCoordinates.y = htmlcanvas.offsetHeight - 85;
		} else if (entryCoordinates.y < 0) {
			entryCoordinates.y = 0;
		}

		// determine the direction
		var direction = 0;
		if (movementX > 0) {
			direction = 1;
		} else if (movementX < 0) {
			direction = -1;
		}

		// clear and render the spaceship
		//ctx.clearRect(0,0,400,400);
		//generateStars(ctx);
		//showShip(entryCoordinates.x, entryCoordinates.y, direction,ctx);
		let coor = `entryCoordinates: (${entryCoordinates.x} ; ${entryCoordinates.y}), movement: (${movementX} ; ${movementY})`;
		document.getElementById("coords").innerHTML = coor;

		camera.rotate(Direction.Up, movementY / -100);
		camera.rotate(Direction.Right, movementX / 100);
		draw();
	}

	// Returns a position based on a mouseevent on a canvas. Based on code
	// from here: http://miloq.blogspot.nl/2011/05/coordinates-mouse-click-canvas.html
	function getPosition(canvas, event) {
		var x = new Number();
		var y = new Number();

		if (event.x != undefined && event.y != undefined) {
			x = event.x;
			y = event.y;
		}
		else // Firefox method to get the position
		{
			x = event.clientX + document.body.scrollLeft +
					document.documentElement.scrollLeft;
			y = event.clientY + document.body.scrollTop +
					document.documentElement.scrollTop;
		}

		x -= canvas.offsetLeft;
		y -= canvas.offsetTop;

		return {x:x, y:y};
	}

	/////////////////////////////////


	var prev_mouse_x = 0;//htmlcanvas.width / 2;
	var prev_mouse_y = 0;
	htmlcanvas.addEventListener("mousemove", (event) => {
		let x = event.offsetX;
		let y = event.offsetY;
		//let coor = "Coordinates: (" + x + " ; " + y + ")";
		//document.getElementById("coords").innerHTML = coor;

		/*if (mouse_grabbed) {
			camera.rotate(Direction.Up, (prev_mouse_y - event.clientY) / 1000);
			camera.rotate(Direction.Right, (prev_mouse_x - event.clientX) / -1000);
			prev_mouse_y = event.clientY;
			prev_mouse_x = event.clientX;
			console.log('X: ' + event.clientX);
			console.log('Y: ' + event.clientY);
			draw();
		}*/
	});

	function toggleAnimation(checkbox) {
		rotate_items_toggle = checkbox.checked;
	}




	/////////////////
	//raytracing
	function gen_rays(camera, resolution) {
		res = [];
		let x_axis = v3_norm(camera.getAB());
		let y_axis = v3_norm(camera.getAC());
		for (var i = 0; i < camera.canvas_width; i += resolution) {
			for (var j = 0; j < camera.canvas_height; j += resolution) {
				let pt = v3_add(v3_add(camera.A, v3_scale(x_axis, i)), v3_scale(y_axis, j));
				res.push(new Line(camera.eye, pt));
			}
		}
		return (res);
	}

	/* https://hugi.scene.org/online/hugi24/coding%20graphics%20chris%20dragan%20raytracing%20shapes.htm */

	/* Plane as constructed by 3 points, NOT the plane Item */
	function intersect_ray_plane(ray, plane) {
		/* ray direction */
		let D = v3_norm(v3_sub(ray.p2, ray.p1));
		/* O - C (o = ray origin, c = point on the plane) */
		let X = v3_sub(ray.p1, plane.p1);
		let N = plane.getNormal();
		let d_v = v3_dot(D, N);
		let x_v = v3_dot(X, N);
		/*if (Math.abs(d_v) <= TOLERANCE) {
			return (null);
		}
		let sign = 1;
		if (!same_sign(d_v, x_v)) {
			sign = -1;
		}
		let t = sign * x_v / d_v;
		if (Math.abs(t) < TOLERANCE) {
			return (null);
		}
		let normal = N;
		if (d_v < 0) {
			normal = v3_invert(N);
		}*/

		if (d_v == TOLERANCE || ((x_v < TOLERANCE) == (d_v < TOLERANCE))) {
			return (null);
		}
		let t = - x_v / d_v;
		let int = v3_add(ray.p1, v3_scale(D, t));
		let normal;
		if (d_v <= TOLERANCE) {
			normal = N;
		} else {
			normal = v3_invert(N);
		}

		return (new RtIntersection(int, normal, ray, plane));
	}

	/* For plane ITEM */
	function intersect_ray_plane_item(ray, plane) {
		let res = intersect_ray_plane(ray, plane_from_normal(plane.pos, plane.scale));
		if (res != null) {
			res.item = plane;
		}
		return (res);
	}
	
	function intersect_ray_sphere(ray, sphere) {
		let D = v3_norm(v3_sub(ray.p2, ray.p1));
		let X = v3_sub(ray.p1, sphere.pos);
		let a = v3_dot(D, D);
		let b = 2 * v3_dot(D, X);
		let r = sphere.scale.x / 2;
		let c = v3_dot(X, X) - r*r;
		let discriminant = b * b - 4 * a * c;
		if (discriminant < TOLERANCE) {
			return (null);
		} else {
			let t1 = (-b + Math.sqrt(discriminant)) / (2 * a);
			let t2 = (-b - Math.sqrt(discriminant)) / (2 * a);
			let point;
			if (t1 >= 0 && t1 < t2) {
				point = v3_add(ray.p1, v3_scale(D, t1));
			} else if (t2 >= 0) {
				point = v3_add(ray.p1, v3_scale(D, t2));
			}
			if (point) {
				return (new RtIntersection(point, v3_norm(v3_sub(point, sphere.pos)), ray, sphere));
			}
		}
		return (null);
	}
	
	function point_inside_square(s1, s2, s3, s4, point) {
		let plane = new Plane(s1, s2, s3);
		let norm = plane.getNormal();
		let altitudeComponent = Math.abs(v3_dot(v3_sub(point, s1), norm));
		if (altitudeComponent >= TOLERANCE) {
			return (false);
		}
		if (!same_side_of_line(new Line(s1, s2), s3, point)) {
			return (false);
		}
		if (!same_side_of_line(new Line(s2, s3), s1, point)) {
			return (false);
		}
		if (!same_side_of_line(new Line(s3, s4), s1, point)) {
			return (false);
		}
		if (!same_side_of_line(new Line(s4, s1), s3, point)) {
			return (false);
		}
		return (true);
	}
	function get_cube_squares(cube) {
		return ([
			[cube.vertices[0], cube.vertices[1], cube.vertices[2], cube.vertices[3]],
			[cube.vertices[1], cube.vertices[2], cube.vertices[6], cube.vertices[5]],
			[cube.vertices[2], cube.vertices[3], cube.vertices[7], cube.vertices[6]],
			[cube.vertices[0], cube.vertices[3], cube.vertices[7], cube.vertices[4]],
			[cube.vertices[0], cube.vertices[1], cube.vertices[5], cube.vertices[4]],
			[cube.vertices[7], cube.vertices[6], cube.vertices[5], cube.vertices[4]]
			]);
	}
	function intersect_ray_cube(ray, cube) {
		let res = null;
		let dist = 0;

		let cube_squares = get_cube_squares(cube);
		for (var i = 0; i < cube_squares.length; i++) {
			let plane = new Plane(cube_squares[i][0], cube_squares[i][1], cube_squares[i][2]);
			let int = intersect_ray_plane(ray, plane);
			if (int != null) {
				if (point_inside_square(cube_squares[i][0], cube_squares[i][1], cube_squares[i][2], cube_squares[i][3], int.pos)) {
					let dist_ = v3_len(v3_sub(int.pos, ray.p1));
					if (res == null || dist_ < dist) {
						res = int;
						dist = dist_;
					}
				}
			}
		}
		if (res != null) {
			res.item = cube;
		}
		return (res);
	}
	
	function point_inside_triangle(s1, s2, s3, point) {
		let plane = new Plane(s1, s2, s3);
		let norm = plane.getNormal();
		let altitudeComponent = Math.abs(v3_dot(v3_sub(point, s1), norm));
		if (altitudeComponent >= TOLERANCE) {
			return (false);
		}
		if (!same_side_of_line(new Line(s1, s2), s3, point)) {
			return (false);
		}
		if (!same_side_of_line(new Line(s1, s3), s2, point)) {
			return (false);
		}
		if (!same_side_of_line(new Line(s2, s3), s1, point)) {
			return (false);
		}
		return (true);
	}
	function get_pyramid_base_square(pyramid) {
		return ([pyramid.vertices[1], pyramid.vertices[2], pyramid.vertices[3], pyramid.vertices[4]]);
	}
	function get_pyramid_triangles(pyramid) {
		return ([
			[pyramid.vertices[0], pyramid.vertices[1], pyramid.vertices[4]],
			[pyramid.vertices[0], pyramid.vertices[1], pyramid.vertices[2]],
			[pyramid.vertices[0], pyramid.vertices[2], pyramid.vertices[3]],
			[pyramid.vertices[0], pyramid.vertices[3], pyramid.vertices[4]]
			]);
	}
	function intersect_ray_pyramid(ray, pyramid) {
		let res = null;
		let dist = 0;
		
		let base_square = get_pyramid_base_square(pyramid);
		let plane = new Plane(base_square[0], base_square[1], base_square[2]);
		let int = intersect_ray_plane(ray, plane);
		if (int) {
			if (point_inside_square(base_square[0], base_square[1], base_square[2], base_square[3], int.pos)) {
				let dist_ = v3_len(v3_sub(int.pos, ray.p1));
				if (res == null || dist_ < dist) {
					res = int;
					dist = dist_;
				}
			}
		}
		let triangles = get_pyramid_triangles(pyramid);
		for (var i = 0; i < triangles.length; i++) {
			plane = new Plane(triangles[i][0], triangles[i][1], triangles[i][2]);
			int = intersect_ray_plane(ray, plane);
			if (int != null) {
				if (point_inside_triangle(triangles[i][0], triangles[i][1], triangles[i][2], int.pos)) {
					let dist_ = v3_len(v3_sub(int.pos, ray.p1));
					if (res == null || dist_ < dist) {
						res = int;
						dist = dist_;
					}
				}
			}
		}
		if (res != null) {
			res.item = pyramid;
		}
		return (res);
	}

	function intersect_ray_cylinder(ray, cylinder) {
		let res = null;
		let dist = 0;

		let cylinder_length = cylinder.scale.y;
		let radius = cylinder.scale.x / 2;
		let D = v3_norm(v3_sub(ray.p2, ray.p1));
		let V = (v3_norm(v3_sub(cylinder.vertices[0], cylinder.vertices[cylinder.vertices.length/2])));
		let C = get_cylinder_top(cylinder);
		let bottom = get_cylinder_bottom(cylinder);

		let X = v3_sub(ray.p1, C);

		/* Testing cylinder caps */
		let plane_top = new Plane(cylinder.vertices[cylinder.vertices.length - 1], cylinder.vertices[cylinder.vertices.length - 2], cylinder.vertices[cylinder.vertices.length - 3]);
		let plane_top_int = intersect_ray_plane(ray, plane_top);
		if (plane_top_int != null) { 
			if (v3_len(v3_sub(C, plane_top_int.pos)) <= radius) {
				let dist_ = v3_len(v3_sub(plane_top_int.pos, ray.p1));
				if (res == null || dist_ < dist) {
					res = plane_top_int;
					dist = dist_;
				}
			}
		}

		let plane_bottom = new Plane(cylinder.vertices[0], cylinder.vertices[1], cylinder.vertices[2]);
		let plane_bottom_int = intersect_ray_plane(ray, plane_bottom);
		if (plane_bottom_int != null) { 
			if (v3_len(v3_sub(bottom, plane_bottom_int.pos)) <= radius) {
				let dist_ = v3_len(v3_sub(plane_bottom_int.pos, ray.p1));
				if (res == null || dist_ < dist) {
					res = plane_bottom_int;
					dist = dist_;
				}
			}
		}

		let t = null;
		let a = v3_dot(D, D) - Math.pow(v3_dot(D, V), 2);
		let b = 2 * (v3_dot(D, X) - v3_dot(D, V) * v3_dot(X, V));
		let c = v3_dot(X, X) - Math.pow(v3_dot(X, V), 2) - radius * radius;
		let discriminant = b * b - 4 * a * c;
		if (discriminant < 0)
		{
			return (res);
		}
		let d1 = (-b + Math.sqrt(discriminant)) / (2 * a);
		let d2 = (-b - Math.sqrt(discriminant)) / (2 *a);
		let m1 = v3_dot(D, V) * d1 + v3_dot(X, V);
		let m2 = v3_dot(D, V) * d2 + v3_dot(X, V);
		let	tmp;
		if (d2 > d1)
		{
			tmp = d1;
			d1 = d2;
			d2 = tmp;
			tmp = m1;
			m1 = m2;
			m2 = tmp;
		}
		if (m2 < cylinder.scale.y && m2 > 0) {
			if (d2 < 0)
			{
				return (res);
			}
			t = d2;
		}

		if (t != null && t >= 0 && (res == null || v3_len(v3_scale(D, t)) < dist)) { //TODO: check whether it's actually v3_scale
			let pos = v3_add(ray.p1, v3_scale(D, t));
			let normal = v3_norm(v3_sub(v3_sub(pos, C), v3_scale(V, m2)));
			res = new RtIntersection(pos, normal, ray, cylinder);
		}
		if (res != null) {
			res.item = cylinder;
		}
		return (res);
	}

	function ray_intersection(ray, object) {
		if (object.type == ObjectType.Plane) {
			return (intersect_ray_plane_item(ray, object));
		} else if (object.type == ObjectType.Sphere) {
			return (intersect_ray_sphere(ray, object));
		} else if (object.type == ObjectType.Cube) {
			return (intersect_ray_cube(ray, object));
		} else if (object.type == ObjectType.Pyramid) {
			return (intersect_ray_pyramid(ray, object));
		} else if (object.type == ObjectType.Cylinder) {
			return (intersect_ray_cylinder(ray, object));
		}
		return ([]);
	}


	function set_cam_pos() {
		camera.A = v3(-1.000, 1.000, -3.600);
		camera.B = v3(1.000, 1.000, -3.600);
		camera.C = v3(-1.000, -1.000, -3.600);
		camera.eye = v3(0.000, 0.000, -2.600);
		draw();
	}
	var lights = [];

	let ambient = new LightAmbient(intensity_to_color(0.3));
	let light_point1 = new LightPoint(intensity_to_color(1), v3(0, 2, -1));
	let light_point2 = new LightPoint(intensity_to_color(1), v3(-3, 0, -2));

	lights.push(ambient);
	lights.push(light_point1);
	//lights.push(light_point2);

	var debugg = null;

	function draw_lights() {
		for (var i = 0; i < lights.length; i++) {
			if (lights[i] instanceof LightPoint) {
				let projection = map_point_to_physical(camera, project_point(lights[i].pos, camera), htmlcanvas.width, htmlcanvas.height);
				if (projection) {
					ctx.drawImage(sun_image, projection.x - 25, projection.y - 25, 50, 50);
				}
			}
		}
	}

	/*
	ComputeLighting(P, N) {
		i = 0.0
		for light in scene.Lights {
			if light.type == ambient {
				i += light.intensity
			} else {
				if light.type == point {
					L = light.position - P
				} else {
					L = light.direction
				}
				n_dot_l = dot(N, L)
				if n_dot_l > 0 {
					i += light.intensity * n_dot_l/(length(N) * length(L))
				}
			}
		}
		return i
	}
	*/	

	/* From book 'Computer Graphics from Scratch' by Gabriel Gambetta */
	function compute_lighting(intersection) {
		let point = intersection.pos;
		let normal = intersection.normal;
		let item = intersection.item;
		let res = v3();
		for (let i=0; i < lights.length; i ++) {
			if (lights[i] instanceof LightAmbient) {
				res = add_colors(res, lights[i].color);
			} else {
				let L = null;
				if (lights[i] instanceof LightPoint) {
					let int = cast_ray(new Line(lights[i].pos, point), false);
					if (int && int.item.id != item.id) {
						if (v3_len(v3_sub(int.pos, point)) < v3_len(v3_sub(point, lights[i].pos))) {
							continue ;
						}
					}
					L = v3_sub(lights[i].pos, point);
				} else {
					L = lights[i].direction;
				}
				let n_dot_l = v3_dot(normal, L);
				if (n_dot_l > 0) {
					res = add_colors(res, modify_color_intensity(lights[i].color, n_dot_l/(v3_len(normal) * v3_len(L))));
					//i += light.intensity * n_dot_l/(length(N) * length(L))
				}
			}
		}
		res.x = res.x / 255;
		res.y = res.y / 255;
		res.z = res.z / 255;
		return (res);
	}

	function compute_specular(intersection) {
		if (intersection.item.specular == -1) {
			return v3();
		}
		let point = intersection.pos;
		let normal = intersection.normal;
		let item = intersection.item;
		let res = v3();
		for (let i=0; i < lights.length; i ++) {
			if (lights[i] instanceof LightAmbient) {
				continue ;
			}
			let L = null;
			if (lights[i] instanceof LightPoint) {
				let int = cast_ray(new Line(lights[i].pos, point), false);
				if (int && int.item.id != item.id) {
					if (v3_len(v3_sub(int.pos, point)) < v3_len(v3_sub(point, lights[i].pos))) {
						continue ;
					}
				}
				L = v3_sub(lights[i].pos, point);
			} else {
				L = lights[i].direction;
			}
			let n_dot_l = v3_dot(normal, L);
			let R = v3_sub(v3_scale(normal, 2 * v3_dot(normal, L)), L);
			let V = v3_invert(v3_norm(v3_sub(intersection.ray.p2, intersection.ray.p1))); // Vector from the point towards the camera
			let r_dot_v = v3_dot(R, V);
			if (r_dot_v > 0) {
				let new_col = modify_color_intensity(lights[i].color, Math.pow(r_dot_v / (v3_len(R) * v3_len(V)), item.specular));
				res = add_colors(res, new_col);
			}
		}
		return (res);
	}

	/* http://raytracerchallenge.com/bonus/texture-mapping.html */
	/* archive: https://archive.md/c96z4 */
	function uv_at_chekers(color1, color2, checkers_width, checkers_height, u, v) {
		let u2 = Math.floor(u * checkers_width);
		let v2 = Math.floor(v * checkers_height);

		if ((u2 + v2) % 2 == 0) {
			return (color1);
		} else {
			return (color2);
		}
	}

	function uv_at_image(rt_image, u, v) {
		let target_height = Math.floor(new_image_height(rt_image.img, rt_image.target_width));
		v = (1 - v) % 1;

		let x = Math.floor(u * (rt_image.target_width - 1));
		let y = Math.floor(v * (target_height - 1));

		return (rt_image.pixels[y][x]);
	}

	function spherical_map(point, sphere) {
		point = v3_add(point, v3_sub(v3(), sphere.pos));
		let theta = Math.atan2(point.x, point.z);
		let radius = v3_len(point);
		let phi = Math.acos(point.y / radius);
		let raw_u = theta / (2 * Math.PI);
		let u = 1 - (raw_u + 0.5);
		let v = 1 - phi / Math.PI;
		return ([u, v]);
	}

	function planar_map(point, plane) {
		let u = point.x % 1;
		if (u < 0) {
			//u = (u + u / 2) % 1;
		}
		let v = point.y % 1;
		return ([u, v]);
	}

	function cylindrical_map(point, cylinder) {
		//point = v3_add(point, v3_sub(v3(), cylinder.pos));
		/* expressing point in local coords */
		let y_axis = cylinder.get_axis();
		let plane = plane_from_normal(cylinder.pos, y_axis);
		let z = plane.p2;
		let x = plane.p3;
		let y = v3_add(cylinder.pos, y_axis);
		
		let z_axis = v3_norm(v3_sub(z, cylinder.pos));
		let x_axis = v3_norm(v3_sub(x, cylinder.pos));

		let xy_plane = new Plane(cylinder.pos, x, y);
		let xy_proj = project_point_onto_plane(point, xy_plane);
		let x_proj = project_point_onto_line(new Line(cylinder.pos, x), xy_proj);
		let x_dist = v3_len(v3_sub(cylinder.pos, x_proj));
		if (v3_dot(x_axis, v3_sub(x_proj, cylinder.pos)) < 0) {
			x_dist *= -1;
		}
		let y_proj = project_point_onto_line(new Line(cylinder.pos, y), xy_proj);
		let y_dist = v3_len(v3_sub(cylinder.pos, y_proj));
		if (v3_dot(y_axis, v3_sub(y_proj, cylinder.pos)) < 0) {
			y_dist *= -1;
		}
		let zy_plane = new Plane(cylinder.pos, z, y);
		let zy_proj = project_point_onto_plane(point, zy_plane);
		let z_proj = project_point_onto_line(new Line(cylinder.pos, z), zy_proj);
		let z_dist = v3_len(v3_sub(cylinder.pos, z_proj));
		if (v3_dot(z_axis, v3_sub(z_proj, cylinder.pos)) < 0) {
			z_dist *= -1;
		}
		point = v3(x_dist, y_dist, z_dist);

		/* for some reason it doesn't work */
		//point = express_point_in_basis(point, x_axis, y_axis, z_axis);

		// compute the azimuthal angle, same as with spherical_map()
		let theta = Math.atan(point.x, point.z);
		let raw_u = theta / (2 * Math.PI);
		let u = (1 - (raw_u + 0.5)) % 1;

		// let v go from 0 to 1 between whole units of y
		let v = point.y % 1;

		return ([u, v]);
	}

	//var pixels_cache = null;
	//var cache_width = 0;
	function get_item_color_image(int) {
		if (int.item.type == ObjectType.Plane) {
			let n = int.normal;
			let n_ = v3(0, 0, 1);
			let angle = vect_angle(n, n_);
			/* rotating the point as if the normal of the plane was n_ */
			let new_pos = v3_add(v3_scale(int.pos, Math.cos(angle)), v3_add(v3_scale(v3_cross(n, int.pos), Math.sin(angle)), v3_scale(n, v3_dot(n, int.pos) * (1 - Math.cos(angle)))));
			if (equals_with_tolerance(n.x, 0) && equals_with_tolerance(n.y, 1) && equals_with_tolerance(n.z, 0)) {
				new_pos = v3(int.pos.x, int.pos.z);
			}
			
			new_pos.x = Math.trunc(new_pos.x % int.item.image.target_width);
			if (new_pos.x < 0) {
				new_pos.x = int.item.image.target_width + new_pos.x;
			}
			new_pos.y = Math.trunc(new_pos.y % new_image_height(int.item.image.img, int.item.image.target_width));
			if (new_pos.y > 0) {
				new_pos.y = new_image_height(int.item.image.img, int.item.image.target_width) - new_pos.y;
			}
			let pixel = int.item.image.pixels[Math.abs(Math.floor(new_pos.y))][Math.abs(Math.floor(new_pos.x))];

			return (v3(pixel.x, pixel.y, pixel.z));
		} else if (int.item.type == ObjectType.Sphere) {
			let new_pixels;
			if (int.item.cache_width == int.item.image.img.width) {
				new_pixels = int.item.pixel_cache;
			} else {
				int.item.cache_width = int.item.image.img.width;
				new_pixels = get_pixels_from_image(int.item.image.img, int.item.image.img.width);
				int.item.pixel_cache = new_pixels;
			}
			let coords = cartesian_to_sphere(int.pos, int.item);
			/* taking theta and phi */
			let x_coord = coords.y; // theta
			let y_coord = coords.z; // phi

			let u = x_coord / (2 * Math.PI);
			let v = y_coord / Math.PI;

			// Map UV coordinates to image coordinates
			x = Math.floor(u * (int.item.image.img.width - 1))
			y = Math.floor(v * (new_image_height(int.item.image.img, int.item.image.img.width) - 1))
			let pixel = new_pixels[y][x];
			return (v3(pixel.x, pixel.y, pixel.z));
		} else if (int.item.type == ObjectType.Cylinder) {
			let u_v = cylindrical_map(int.pos, int.item);
			let img_color = uv_at_image(int.item.image, u_v[0], u_v[1]);
			/* TODO: transparency check / blend */
			return(v3(img_color.x, img_color.y, img_color.z));
		} else if (int.item.type == ObjectType.Cube || int.item.type == ObjectType.Pyramid) {
			let plane = get_intersection_plane(int);
			let x_axis = v3_norm(v3_sub(plane.p2, plane.p1));
			let y_axis = v3_norm(v3_sub(plane.p3, plane.p1));
			let x_proj = project_point_onto_line(new Line(plane.p1, plane.p2), int.pos);
			let x_dist = v3_len(v3_sub(plane.p1, x_proj));
			/*if (v3_dot(x_axis, v3_sub(x_proj, plane.p1)) < 0) {
				x_dist *= -1;
			}*/
			let y_proj = project_point_onto_line(new Line(plane.p1, plane.p3), int.pos);
			let y_dist = v3_len(v3_sub(plane.p1, y_proj));
			/*if (v3_dot(y_axis, v3_sub(y_proj, plane.p1)) < 0) {
				y_dist *= -1;
			}*/
			x_dist %= int.item.image.target_width - 1;
			y_dist %= new_image_height(int.item.image.img, int.item.image.target_width) - 1;
			let pixel = int.item.image.pixels[Math.floor(y_dist * 1000)][Math.floor(x_dist * 1000)];
			return (v3(pixel.x, pixel.y, pixel.z));
		}
	}

	function get_item_color(int) {
		if (int.item.image != null) {
			return get_item_color_image(int);
		} else if (int.item.is_checker) {
			return(get_item_color_checkerboard(int));
		} else {
			return (int.item.color);
		}
	}

	/* https://stackoverflow.com/a/1024061 */
	/* consistent x, y mapping on a plane with an arbitrary rotation applied to it */
	/*
		point: point to map
		origin: origin of the plane
		normal: normal of the plane
	*/
	function normalize_plane_point(point, origin, normal) {
		if (equals_with_tolerance(Math.abs(normal.x), 1) && normal.y == 0 && normal.z == 0) {
			let z_axis = v3(0, 0, 1);
			let new_y_axis = v3_norm(v3_cross(z_axis, normal));
			let new_x_axis = v3_norm(v3_cross(normal, new_y_axis));
			let origin_to_point = v3_sub(point, origin);
			return (v3(v3_dot(origin_to_point, new_x_axis), v3_dot(origin_to_point, new_y_axis)));
		}
		let x_axis = v3(1, 0, 0);
		let new_y_axis = v3_norm(v3_cross(x_axis, normal));
		let new_x_axis = v3_norm(v3_cross(normal, new_y_axis));
		let origin_to_point = v3_sub(point, origin);
		return (v3(v3_dot(origin_to_point, new_x_axis), v3_dot(origin_to_point, new_y_axis)));
	}

	function cartesian_to_sphere(point, sphere) {
		let rho = v3_len(v3_sub(point, sphere.pos));
		// z axis is sphere.rot
		z_axis = sphere.get_axis();
		if (sphere.rot.x == 0 && sphere.rot.y == 0 && sphere.rot.z == 0) {
			z_axis = v3(0, 1);
		}
		let phi = vect_angle(z_axis, v3_sub(point, sphere.pos));
		let plane = plane_from_normal(sphere.pos, z_axis);
		let proj = project_point_onto_plane(point, plane);
		/* the following works because of how plane_from_normal behaves (p1 is sphere.pos) */
		let theta = vect_angle(v3_sub(plane.p2, sphere.pos), v3_sub(proj, sphere.pos));
		return (v3(rho, theta, phi));
	}

	function checker_pixel_for_plane(point, origin, normal, step, color1, color2) {
		let new_pos = normalize_plane_point(point, origin, normal);
		if (new_pos.x < 0) {
			new_pos.x -= step;
		}
		if (new_pos.y < 0) {
			new_pos.y -= step;
		}
		const checkerX = Math.floor(Math.abs(new_pos.x) / step);
		const checkerY = Math.floor(Math.abs(new_pos.y) / step);
		const parityX = checkerX % 2;
		const parityY = checkerY % 2;
		if (parityX === parityY) {
			return (color1);
		} else {
			return (color2);
		}
	}

	function get_intersection_plane(int) {
		let nearest_plane;
		let nearest_plane_dist;
		if (int.item.type == ObjectType.Cube) {
			let squares = get_cube_squares(int.item);
			for (var i = 0; i < squares.length; i++) {
				let plane = new Plane(squares[i][0], squares[i][1], squares[i][2]);
				let dist_ = point_plane_dist(int.pos, plane);
				if (!nearest_plane || dist_ < nearest_plane_dist) {
					nearest_plane = plane;
					nearest_plane_dist = dist_;
				}
			}
		} else /* pyramid */ {
			let triangles = get_pyramid_triangles(int.item);
			triangles.push(get_pyramid_base_square(int.item));
			for (var i = 0; i < triangles.length; i++) {
				let plane = new Plane(triangles[i][0], triangles[i][1], triangles[i][2]);
				let dist_ = point_plane_dist(int.pos, plane);
				if (!nearest_plane || dist_ < nearest_plane_dist) {
					nearest_plane = plane;
					nearest_plane_dist = dist_;
				}
			}
		}
		return (nearest_plane);
	}

	function get_item_color_checkerboard(int) {
		let inverse_color = v3_sub(WHITE, int.item.color);
		if (int.item.type == ObjectType.Plane) {
			return (checker_pixel_for_plane(int.pos, int.item.pos, int.item.scale, 2, inverse_color, int.item.color));
		} else if (int.item.type == ObjectType.Sphere) {
			let u_v = spherical_map(int.pos, int.item);
			return(uv_at_chekers(int.item.color, inverse_color, 32, 8, u_v[0], u_v[1]));
		} else if (int.item.type == ObjectType.Cylinder) {
			let u_v = cylindrical_map(int.pos, int.item);
			return(uv_at_chekers(int.item.color, inverse_color, 32, 8, u_v[0], u_v[1]));
		} else if (int.item.type == ObjectType.Cube) {
			let nearest_plane = get_intersection_plane(int);
			return (checker_pixel_for_plane(int.pos, nearest_plane.p2, nearest_plane.getNormal(), int.item.scale.x / 10, inverse_color, int.item.color));
		} else if (int.item.type == ObjectType.Pyramid) {
			let nearest_plane = get_intersection_plane(int);
			return (checker_pixel_for_plane(int.pos, nearest_plane.p2, nearest_plane.getNormal(), int.item.scale.x / 10, inverse_color, int.item.color));
		} else {
			
			return (int.item.color);
		}
	}

	function cast_ray(ray, do_draw = true) {
		let intersection = null;
		let dist = 0;
		for (var j = 0; j < items.length; j++) {
			let int_ = ray_intersection(ray, items[j]);
			if (int_ != null) {
				let dist_ = v3_len(v3_sub(int_.pos, ray.p1));
				if (intersection == null || dist_ < dist) {
					intersection = int_;
					dist = dist_;
				}
			}
		}
		if (do_draw && intersection != null) {
			//console.log('drawing pixel');
			let mapped_point = map_point_to_physical(camera, intersection.ray.p2, htmlcanvas.width, htmlcanvas.height);
			let light_color = compute_lighting(intersection);
			let specular_coefficient = 0.7;
			let specular_color = modify_color_intensity(compute_specular(intersection), specular_coefficient);
			let color;
			if (1) {
				let diffuse_color = mult_colors(get_item_color(intersection), light_color);
				color = rgbToHexV3(add_colors(diffuse_color, specular_color)); //rgbToHexV3(mult_colors(get_item_color(intersection), light_color));
			} else {
				color = rgbToHexV3(get_item_color(intersection));
			}
			draw_circle(mapped_point.x, mapped_point.y, 1, color, 2);
		}
		return (intersection);
	}

	function raytrace() {
		if (parseFloat(document.getElementById('rt_precision').value < TOLERANCE)) {
			return ;
		}
		
		console.log("raytracing...");
		let rays = gen_rays(camera, parseFloat(document.getElementById('rt_precision').value));

		console.log(rays.length)
		console.log(rays);
		for (var i = 0; i < rays.length; i++) {
			cast_ray(rays[i]);
		}
		console.log("done!");
		draw_lights();
	}

	function cast_ray_for_screen_coords(x, y) {
		console.log(`casting for ${x}, ${y}`);
		let mapped = map_physical_to_camera(camera, v3(x, y), htmlcanvas.width, htmlcanvas.height);
		cast_ray(new Line(camera.eye, mapped), true);
	}
</script>

</body></html>
