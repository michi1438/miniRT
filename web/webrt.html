<!DOCTYPE html>
<html lang="en"><head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>webrt</title>
</head>
<body>

	<canvas style="border: solid" id="canvas"></canvas>
	<p id="coords">Coordinates: (-1 ; -1)</p>

	<input type="checkbox" id="animationToggleCheckbox" onchange="toggleAnimation(this)">
	<label for="animationToggle">Toggle Animation</label>

	<br>
	<br>
	<button onclick="raytrace();">Raytrace</button>
	<br>
	<input type="number" id="rt_precision" name="quantity" min="0.0001" max="10" value="0.01">


<script>
	function same_sign(a, b) {
		return ((a >= 0 && b >= 0) || (a <= 0 && b <= 0));
	}

	const Direction = {
		Forward: 0,
		Backward: 1,
		Left: 2,
		Right: 3,
		Up: 4,
		Down: 5
	}

	const ObjectType = {
		Plane: 0,
		Sphere: 1,
		Cube: 2,
		Pyramid: 3,
		Cylinder: 4
	}

	class V3 {
	  constructor(x, y, z) {
	    this.x = x;
	    this.y = y;
	    this.z = z;
	  }

	  toString() {
			return ('[' + this.x.toFixed(3) + ', ' + this.y.toFixed(3) + ', ' + this.z.toFixed(3) + ']')
		}
	}

	class Plane {
	  constructor(p1, p2, p3) {
	    this.p1 = p1;
	    this.p2 = p2;
	    this.p3 = p3;
	  }

	  getNormal() {
	  	return(v3_norm(v3_cross(v3_sub(this.p2, this.p1), v3_sub(this.p3, this.p1))));
	  }
	}

	class Line {
		constructor(p1, p2) {
			this.p1 = p1;
			this.p2 = p2;
		}
	}

	class Matrix3d {
		constructor(v1, v2, v3) {
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;
		}

		toString() {
			return ('[' + this.v1 + ', ' + this.v2 + ', ' + this.v3 + ']')
		}
	}

	function same_side_of_line(line, A, B) {
		let cross1 = v3_cross(v3_sub(line.p2, line.p1), v3_sub(A, line.p1));
		let cross2 = v3_cross(v3_sub(line.p2, line.p1), v3_sub(B, line.p1));
		return (v3_dot(cross1, cross2) >= 0);
	}

	function same_side_of_plane(plane, A, B) {
		let dot1 = v3_dot(plane.getNormal(), v3_sub(A, plane.p1));
		let dot2 = v3_dot(plane.getNormal(), v3_sub(B, plane.p1));
		return (same_sign(dot1, dot2));
	}

	/* rotate point p, by a vector v, around a point r */
	function rotate_point(p, v, r) {
		let rot_matrix_x = new Matrix3d(
			v3(1, 0, 0),
			v3(0, Math.cos(v.x), Math.sin(v.x)),
			v3(0, -Math.sin(v.x), Math.cos(v.x))
			);

		let rot_matrix_y = new Matrix3d(
			v3(Math.cos(v.y), 0, -Math.sin(v.y)),
			v3(0, 1, 0),
			v3(Math.sin(v.y), 0, Math.cos(v.y))
			);

		let rot_matrix_z = new Matrix3d(
			v3(Math.cos(v.z), Math.sin(v.z), 0),
			v3(-Math.sin(v.z), Math.cos(v.z), 0),
			v3(0, 0, 1)
			);

		/* combined rotation matrix */
		let rot_matrix = matrix_mult(rot_matrix_x, matrix_mult(rot_matrix_y, rot_matrix_z));

		/* translation of point p so r becomes the origin */
		let p_translate = v3_sub(p, r);

		let p_rotated1 = matrix_mult_vec(rot_matrix, p_translate);

		return (v3_add(p_rotated1, r));
	}

	/* projects a point on the camera plane */
	/* returns null if the line between eye and point doesn't intersect plane or is behind screen */
	var count = 4;
	function project_point(point, camera) {
		console.log('projecting point P' + count);
		count --;
		console.log(point);

		/* FRUSTUM CULLING */
		/* check for y axis */		
		if (!same_side_of_plane(new Plane(camera.eye, camera.A, camera.C), camera.B, point)) {
			return (null);
		}
		if (!same_side_of_plane(new Plane(camera.eye, camera.B, camera.getD()), camera.A, point)) {
			return (null);
		}
		/* check for x axis */
		if (!same_side_of_plane(new Plane(camera.eye, camera.C, camera.getD()), camera.A, point)) {
			return (null);
		}
		if (!same_side_of_plane(new Plane(camera.eye, camera.A, camera.B), camera.C, point)) {
			return (null);
		}

		let line = new Line(camera.eye, point);
		let canvas = camera.getCanvasPlane();
		console.log('result:');
		console.log(intersect(line, canvas));
		let intersection = intersect(line, canvas);
		if (intersection == null) {
			return (null);
		}
		
		return (intersection);
	}

	/* Converting degrees to radians */
	function degree_to_radian(angle) {
		return (angle * Math.PI / 180);
	}

	function expressPointInBasis(A, B, C, point) {
	    // Calculate coefficients
	    const denominator = (B.x - A.x) * (C.y - A.y) - (C.x - A.x) * (B.y - A.y);

	    const x = ((point.x - A.x) * (C.y - A.y) - (C.x - A.x) * (point.y - A.y)) / denominator;
	    const y = ((B.x - A.x) * (point.y - A.y) - (point.x - A.x) * (B.y - A.y)) / denominator;

	    return { x, y };
	}

	/*
	and the screen is eye_canv_dist distant from (0, 0, 0)
	A-------------------------B
	|						  |
	|						  |
	|         (eye)           |
	|						  |
	|						  |
	C-------------------------o
	*/
	class Camera {
		constructor(eye_canv_dist, screen_width, screen_height) {
			this.canvas_width = screen_width;
			this.canvas_height = screen_height;
			this.eye = v3();
			this.A = v3(-screen_width / 2, screen_height / 2, -eye_canv_dist);
			this.B = v3(screen_width / 2, screen_height / 2, -eye_canv_dist);
			this.C = v3(-screen_width / 2, -screen_height / 2, -eye_canv_dist);
		}

		getAC() {
			return (v3_sub(this.C, this.A));
		}

		getAB() {
			return (v3_sub(this.B, this.A));
		}

		/* fourth bottom right corner */
		getD() {
			return (v3_add(this.B, this.getAC()));
		}

		getCanvasPlane() {
			return (new Plane(this.A, this.B, this.C));
		}

		getCenter() {
			let ab = this.getAB();
			let half_ab = v3_scale(ab, 0.5);
			let top_middle = v3_add(this.A, half_ab);
			let ac = this.getAC();
			let half_ac = v3_scale(ac, 0.5);
			//let left_middle = v3_add(this.A, half_ac);
			return (v3_add(top_middle, half_ac));
		}

		getNorm() {
			return (v3_norm(v3_sub(this.getCenter(), this.eye)));
		}

		rotate(direction, amount) {
			let rot_vect;
			switch (direction) {
				case Direction.Right:
					rot_vect = v3_scale(v3(0, 1), -amount); //v3_scale(v3_norm(this.getAC()), amount);
					this.A = rotate_point(this.A, rot_vect, this.eye);
					this.B = rotate_point(this.B, rot_vect, this.eye);
					this.C = rotate_point(this.C, rot_vect, this.eye);
					break;
				case Direction.Left:
					rot_vect = v3_scale(v3(0, 1), amount); //v3_scale(v3_norm(this.getAC()), -amount);
					this.A = rotate_point(this.A, rot_vect, this.eye);
					this.B = rotate_point(this.B, rot_vect, this.eye);
					this.C = rotate_point(this.C, rot_vect, this.eye);
					break;
				case Direction.Up:
					rot_vect = v3_scale(v3_norm(this.getAB()), amount);
					this.A = rotate_point(this.A, rot_vect, this.eye);
					this.B = rotate_point(this.B, rot_vect, this.eye);
					this.C = rotate_point(this.C, rot_vect, this.eye);
					break;
				case Direction.Down:
					rot_vect = v3_scale(v3_norm(this.getAB()), -amount);
					this.A = rotate_point(this.A, rot_vect, this.eye);
					this.B = rotate_point(this.B, rot_vect, this.eye);
					this.C = rotate_point(this.C, rot_vect, this.eye);
					break;
				default:
					console.log(`Invalid direction: ${dir}.`);
					return ;
			}
		}

		move(direction, amount) {
			let move_vect;
			let vct;
			
			switch (direction) {
				case Direction.Forward:
					vct = v3_sub(this.getCenter(), this.eye);
					vct.y = 0;
					vct = v3_norm(vct);
					move_vect = v3_scale(vct, amount); //v3_scale(this.getNorm(), amount);
					break;
				case Direction.Backward:
					vct = v3_norm(v3_sub(this.getCenter(), this.eye));
					vct.y = 0;
					move_vect = v3_scale(vct, -amount); //v3_scale(this.getNorm(), -amount);
					break;
				case Direction.Right:
					move_vect = v3_scale(v3_norm(this.getAB()), amount);
					break;
				case Direction.Left:
					move_vect = v3_scale(v3_norm(this.getAB()), -amount);
					break;
				case Direction.Up:
					move_vect = v3_scale(v3(0, 1), amount); //v3_scale(v3_norm(this.getAC()), -amount);
					break;
				case Direction.Down:
					move_vect = v3_scale(v3(0, 1), -amount); //v3_scale(v3_norm(this.getAC()), amount);
					break;
				default:
					console.log(`Invalid direction: ${dir}.`);
					return ;
			}
			this.eye = v3_add(move_vect, this.eye);
			this.A = v3_add(move_vect, this.A);
			this.B = v3_add(move_vect, this.B);
			this.C = v3_add(move_vect, this.C);
		}

		/* expresses a 3d point relatively to point A */
		/* x: 2.52 ; y: 0.99 */
		get_point_canvas_rel(p) {
			let AB_proj = project_point_onto_line(new Line(this.A, this.B), p);
			let AC_proj = project_point_onto_line(new Line(this.A, this.C), p);
			let A_AB_proj = v3_sub(AB_proj, this.A);
			let A_AC_proj = v3_sub(AC_proj, this.A);
			let x_mult = 1;
			let y_mult = 1;
			if (!same_side_of_line(new Line(this.A, this.B), this.C, p)) {
				y_mult = -1;
			}
			if (!same_side_of_line(new Line(this.A, this.C), this.B, p)) {
				x_mult = -1;
			}
			return (v3(v3_len(A_AB_proj) * x_mult, v3_len(A_AC_proj) * y_mult));
		}
	}

	function map_point_to_physical(camera, point, physical_width, physical_height) {
		if (point == null) {
			return (null);
		}
		let x_ratio = physical_width / camera.canvas_width;
		let y_ratio = physical_height / camera.canvas_height;

		let rel = camera.get_point_canvas_rel(point);

		//let canvas_x_ratio = point.x / camera.getAB().x;
		return (v3(rel.x * x_ratio, rel.y * y_ratio /* * -1*/));
	}

	function v3(x = 0, y = 0, z = 0) {
		return new V3(x, y, z);
	}

	function v3_add(a, b) {
		return (v3(a.x + b.x, a.y + b.y, a.z + b.z));
	}

	function v3_sub(a, b) {
		return (v3(a.x - b.x, a.y - b.y, a.z - b.z));
	}

	function v3_scale(a, scale) {
		return (v3(a.x * scale, a.y * scale, a.z * scale));
	}

	function v3_invert(a) {
		return (v3_scale(a, -1))
	}

	function v3_abs(a) {
		return (v3(Math.abs(a.x), Math.abs(a.y), Math.abs(a.z)));
	}

	function v3_len(a) {
		return (Math.sqrt(a.x * a.x + a.y * a.y + a.z * a.z));
	}

	function v3_norm(v) {
		return (v3_scale(v, 1/v3_len(v)));
	}

	function v3_norm_squared(v) {
		return (v.x * v.x + v.y * v.y + v.z * v.z);
	}

	function v3_cross(a, b) {
		//return (v3(a.y * b.z - a.z * b.y, a.x * b.z - a.z * b.x, a.x * b.y - a.y * b.x));

		return (
			v3(
				a.y * b.z - a.z * b.y,
				a.z * b.x - a.x * b.z,
				a.x * b.y - a.y * b.x
				)
			);
	}

	function v3_dot(a, b) {
	    return (a.x * b.x + a.y * b.y + a.z * b.z);
	}

	/* https://stackoverflow.com/a/12499474 */
	function project_point_onto_line(line, point) {
		let A = line.p1;
		let B = line.p2;
		let C = point;
		let x1 = A.x, y1 = A.y, z1 = A.z;
	    let x2 = B.x, y2 = B.y, z2 = B.z;
	    let x3 = C.x, y3 = C.y, z3 = C.z;
	    let px = x2 - x1, py = y2 - y1, pz = z2 - z1;
	    let dAB = px * px + py * py + pz * pz;
	    let u = ((x3 - x1) * px + (y3 - y1) * py + (z3 - z1) * pz) / dAB;
    	let x = x1 + u * px, y = y1 + u * py, z = z1 + u * pz;
    	return (v3(x, y, z));
	}

	/* Multiplying a 3D matrix with a 3D vector */
	function matrix_mult_vec(matrix, vec) {
		let v1 = v3_scale(matrix.v1, vec.x);
		let v2 = v3_scale(matrix.v2, vec.y);
		let v3 = v3_scale(matrix.v3, vec.z);
		return (v3_add(v1, v3_add(v2, v3)));
	}

	/* Multiplying two 3D matrices */
	function matrix_mult(m1, m2) {
		let v1 = v3(
				m1.v1.x * m2.v1.x + m1.v2.x * m2.v1.y + m1.v3.x * m2.v1.z,
				m1.v1.y * m2.v1.x + m1.v2.y * m2.v1.y + m1.v3.y * m2.v1.z,
				m1.v1.z * m2.v1.x + m1.v2.z * m2.v1.y + m1.v3.z * m2.v1.z);

		let v2 = v3(
				m1.v1.x * m2.v2.x + m1.v2.x * m2.v2.y + m1.v3.x * m2.v2.z,
				m1.v1.y * m2.v2.x + m1.v2.y * m2.v2.y + m1.v3.y * m2.v2.z,
				m1.v1.z * m2.v2.x + m1.v2.z * m2.v2.y + m1.v3.z * m2.v2.z);

		let v3_ = v3(
				m1.v1.x * m2.v3.x + m1.v2.x * m2.v3.y + m1.v3.x * m2.v3.z,
				m1.v1.y * m2.v3.x + m1.v2.y * m2.v3.y + m1.v3.y * m2.v3.z,
				m1.v1.z * m2.v3.x + m1.v2.z * m2.v3.y + m1.v3.z * m2.v3.z);
		return (new Matrix3d(v1, v2, v3_));
	}

	class Item {
	  constructor(type, pos, scale, rot, color, vertex_func, draw_mapping_func, raytrace_func, line_width = 1) {
	    this.type = type;
	    this.pos = pos;
	    this.scale = scale;
	    this.rot = rot;
	    if (rot.x == 0 && rot.y == 0 && rot.z == 0) {
	    	//this.rot = v3(0, -1);
	    }
	    this.color = color;
	    this.vertex_func = vertex_func;
	    this.draw_mapping_func = draw_mapping_func;
	    this.raytrace_func = raytrace_func;
	    this.vertices = vertex_func(pos, scale);
	    rotate_item(this, this.rot);
	  }

	  color_hex() {
	  	return (rgbToHex(this.color.x, this.color.y, this.color.z));
	  }
	}

	function intersect(line, plane) {
		let n = v3_norm(v3_cross(v3_sub(plane.p3, plane.p1), v3_sub(plane.p2, plane.p1))); /* vector normal to the plane */
		let d = -(n.x * plane.p1.x + n.y * plane.p1.y + n.z * plane.p1.z); /* distance from the plane to the origin */ /* it's negative because we want to represent the plane equation as n.x*x + n.y*y + n.z*z + d = 0 */
		let lv = v3_sub(line.p2, line.p1);

		/* plugging in the line eq into the plane eq */
		let divisor = n.x * lv.x + n.y * lv.y + n.z * lv.z;
		if (divisor == 0) {
			return (null);
		}
		let dividend = -(n.x * line.p1.x + n.y * line.p1.y + n.z * line.p1.z + d);
		if (dividend == 0) {
			return (null);
		}
		let t = dividend / divisor;
		return (v3_add(line.p1, v3_scale(lv, t)));
	}
</script>

<script>
	// axis convention: left hand. (inverted y axis on geogebra, left thumb pointing towards user)

	var htmlcanvas = document.getElementById('canvas');
	htmlcanvas.width = 1000;
	htmlcanvas.height = 1000;
	var [RED, GREEN, BLUE, YELLOW, LIGHTBLUE, BLACK, PINK] = [v3(255, 0, 0), v3(0, 255, 0), v3(0, 0, 255), v3(0, 255, 255), v3(68, 85, 90), v3(), v3(255, 222, 251)];
	var ctx = htmlcanvas.getContext('2d');
	const TOLERANCE = 0.000001;//1e-6; // how parallel a line is to the plane means parallel$
	const origin = v3();
	var canvas_dist = 1;
	var canvas_size = v3(2, 2);
	var camera = new Camera(canvas_dist, canvas_size.x, canvas_size.y);

	var debug_toggle = false;
	var mouse_grabbed = false;

	var animationToggleCheckbox = document.getElementById('animationToggleCheckbox');
	var rotate_items_toggle = animationToggleCheckbox.checked;
	var items_rotation_speed = 0.003;

	/*camera.A = v3(6.123958580496993, 1.4816940220588317, -1.6054972595099892);
	camera.B = v3(6.071201285349139,  1.3819623198616062,  -3.602312287344451);
	camera.C = v3( 6.075187559442211, -0.515157480914275, -1.5044751699487897);
	camera.eye = v3(7.0725489710061655,0.4077233294835535,-2.5785148454369);*/

	/*camera.A = v3(0.30116867893975824, 1, -1.2817732906760417);
	camera.B = v3(1.3817732906760416, 1, 0.4011686789397584);
	camera.C = v3(0.30116867893975824, -1, -1.2817732906760417);
	camera.eye = v3(0, 0, 0.1);*/

	var items = [];

	function draw_line(x1, y1, x2, y2, color = 'black', width = 2) {
		ctx.strokeStyle = color;
		ctx.lineWidth = width;
		ctx.beginPath();
		ctx.moveTo(x1, y1);
		ctx.lineTo(x2, y2);
		ctx.stroke();
	}

	function fill_canvas(color = 'white') {
		ctx.fillStyle = color;
		ctx.beginPath();
		ctx.rect(0, 0, htmlcanvas.width,  htmlcanvas.height);
		ctx.fill();
		ctx.closePath();
	}

	function draw_circle(x, y, radius, color = 'black', width = 1) {
		ctx.beginPath();
		ctx.lineWidth = width;
		ctx.strokeStyle = color;
		ctx.arc(x, y, radius, 0, 2 * Math.PI);
		ctx.stroke();
		ctx.closePath();
	}

	function draw_vect(v, color = 'black', width = 1, radius = 5) {
		if (v == null) {
			return ;
		}
		draw_circle(v.x, v.y, radius, color, width);
	}

	/* https://stackoverflow.com/a/5624139 */
	function rgbToHex(r, g, b) {
		return ("#" + (1 << 24 | r << 16 | g << 8 | b).toString(16).slice(1));
	}
	function rgbToHexV3(v) {
		return ("#" + (1 << 24 | v.x << 16 | v.y << 8 | v.z).toString(16).slice(1));
	}
	function hexToRgb(hex) {
		// Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
		var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
		hex = hex.replace(shorthandRegex, function(m, r, g, b) {
			return r + r + g + g + b + b;
		});

		var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
		return result ? {
			r: parseInt(result[1], 16),
			g: parseInt(result[2], 16),
			b: parseInt(result[3], 16)
		} : null;
	}

	function connect_points(p1, p2, item) {
		//console.log('connecting points:');
		//console.log(p1);
		//console.log(p2);
		if (p1 == null || p2 == null) {
			return ;
		}
		draw_vect(p1, item.color_hex(), 0.3);//, '#' + point_connector_color.toString(16));
		draw_vect(p2, item.color_hex(), 0.3);//'#' + point_connector_color.toString(16));
		draw_line(p1.x, p1.y, p2.x, p2.y, item.color_hex(), item.line_width);
	}

	function add_item(item) {
		items.push(item);
	}

	function lerp(start, end, t) {
	    // Linear interpolation function
	    return (1 - t) * start + t * end;
	}

	function smoothColorTransition(counter, maxCounter) {
	    // Function to smoothly transition between colors for a cyclic counter
	    const startColor = [255, 0, 0];  // Red
	    const middleColor = [0, 255, 0]; // Green
	    const endColor = [0, 0, 255];    // Blue

	    const t = counter / maxCounter;
	    if (counter <= maxCounter / 3) {
	        return v3(
	            Math.round(lerp(startColor[0], middleColor[0], t)),
	            Math.round(lerp(startColor[1], middleColor[1], t)),
	            Math.round(lerp(startColor[2], middleColor[2], t))
	        );
	    } else if (counter <= maxCounter / 3 * 2) {
	        return v3(
	            Math.round(lerp(middleColor[0], endColor[0], t)),
	            Math.round(lerp(middleColor[1], endColor[1], t)),
	            Math.round(lerp(middleColor[2], endColor[2], t))
	        );
	    } else {
	    	return v3(
	            Math.round(lerp(endColor[0], startColor[0], t)),
	            Math.round(lerp(endColor[1], startColor[1], t)),
	            Math.round(lerp(endColor[2], startColor[2], t))
	        );
	    }
	}
	var iter = 0;
	var color_iter = 0;
	function animate() {
		if (rotate_items_toggle) {
			for (let i = 0; i < items.length; i++) {
				//scale_item(items[i], v3(0.2 + Math.sin(iter), 0.2 + Math.sin(iter), 0.2 + Math.sin(iter)));
		  		rotate_item(items[i], v3_scale(v3(1, 2, 4), items_rotation_speed));
		  		iter += 0.05;
		  		iter = iter % Math.PI;
		  		color_iter = (color_iter + 1) % 600;

		  		//items[i].color = smoothColorTransition(color_iter, 600);
			}
			draw();
		}
	}

	function draw() {
		console.log('drawing...');
		fill_canvas('black');
		for (let i = 0; i < items.length; i++) {
			outline_item(items[i]);
			
		}

		/* debug overlay */
		if (debug_toggle) {
			function translate_vec(v) {
				return (v3(v.x, v.z));
			}
			draw_vect(v3_scale(v3_add(translate_vec(v3()), v3(10, 10)), 20), 'aqua');
			//canvas_dist = 100;
			
			let a = v3_scale(v3_add(translate_vec(camera.A), v3(10, 10)), 20);
			let b = v3_scale(v3_add(translate_vec(camera.B), v3(10, 10)), 20);
			let c = v3_scale(v3_add(translate_vec(camera.C), v3(10, 10)), 20);
			let d = v3_scale(v3_add(translate_vec(camera.getD()), v3(10, 10)), 20);
			let eye = v3_scale(v3_add(translate_vec(camera.eye), v3(10, 10)), 20);
			draw_vect(a, 'blue');
			draw_vect(b, 'green');
			draw_vect(c, 'orange');
			draw_vect(d, 'pink');
			draw_vect(eye, 'red');



			let ref_point_ = v3_scale(v3_add(translate_vec(v3_add(camera.getCenter(), camera.getNorm())), v3(10, 10)), 20);
			draw_vect(ref_point_, 'lightblue');

			draw_line(a.x, a.y, b.x, b.y, 'grey', 0.5);
			draw_line(b.x, b.y, d.x, d.y, 'grey', 0.5);
			draw_line(d.x, d.y, c.x, c.y, 'grey', 0.5);
			draw_line(c.x, c.y, a.x, a.y, 'grey', 0.5);

			draw_line(a.x, a.y, eye.x, eye.y, 'grey', 0.5);
			draw_line(b.x, b.y, eye.x, eye.y, 'grey', 0.5);
			draw_line(d.x, d.y, eye.x, eye.y, 'grey', 0.5);
			draw_line(c.x, c.y, eye.x, eye.y, 'grey', 0.5);

			
			for (let i = 0; i < items.length; i++) {
				for (let j = 0; j < items[i].vertices.length; j ++) {
					//if (items[i].vertices[j] == null) {
					//	continue ;
					//}
					let pt = v3_scale(v3_add(translate_vec(items[i].vertices[j]), v3(10, 10)), 20);
					//let zero = v3_scale(v3_add(translate_vec(v3()), v3(10, 10)), 20);
					let orig = v3_scale(v3_add(translate_vec(camera.eye), v3(10, 10)), 20);
					draw_vect(pt, 'blueviolet');
					draw_line(pt.x, pt.y, orig.x, orig.y, 'grey', 0.5);
				}
			}
			
			console.log('-------');
			let ab = camera.getAB();
			let ref_point = v3_add(camera.getCenter(), camera.getNorm());
			let ref_cross = v3_cross(ab, ref_point);
			let test_cross = v3_cross(ab, items[0].vertices[0]);
			console.log(ref_point);
			console.log(ref_cross);
			console.log(test_cross);
			console.log('-------');
		}

		if (mouse_grabbed) {
			draw_vect(v3(htmlcanvas.width / 2, htmlcanvas.height / 2), 'red', 1, 3);
		}
	}

	/* returns a list of sphere vertices */
	/* scale.x: radius ; scale.y: amount of vertices around axis y ; scale.z: amount of vertices around axis z */
	function sphere_vertices(pos, scale) {
		let vertices = [];
		
		/*vertices.push(
			v3_add(
				pos,
				v3(0, scale.x / 2)
			);*/

		let top_point = v3_add(pos, v3(0, scale.x / 2));
		for (let i = 1; i <= scale.y; i ++) {
			for (let j = 1; j <= scale.z; j ++) {
				vertices.push(rotate_point(rotate_point(top_point, v3(0, 0, j * Math.PI / (scale.z + 1)), pos), v3(0, i * Math.PI / (scale.y /2), 0), pos));	
			}
		}
		vertices.push(top_point);
		let bottom_point = v3_add(pos, v3(0, -scale.x / 2));
		vertices.push(bottom_point);
		return (vertices);
	}

	/* returns a list of pyramid vertices */
	function pyramid_vertices(pos, scale) {
		let vertices = [];
		
		/*
		vertices.push(
			v3_add(
				pos,
				v3_add(
					v3(X),
					v3_add(
						v3(0, Y),
						v3(0, 0, Z)
						)
					)
				)
			);
			*/

		vertices.push( //1
			v3_add(
				pos,
				v3(0, scale.y / 2)
				)
			);

		vertices.push( //2
			v3_add(
				pos,
				v3_add(
					v3(-scale.x / 2),
					v3_add(
						v3(0, -scale.y / 2),
						v3(0, 0, -scale.z / 2)
						)
					)
				)
			);

		vertices.push( //3
			v3_add(
				pos,
				v3_add(
					v3(scale.x / 2),
					v3_add(
						v3(0, -scale.y / 2),
						v3(0, 0, -scale.z / 2)
						)
					)
				)
			);

		vertices.push( //4
			v3_add(
				pos,
				v3_add(
					v3(scale.x / 2),
					v3_add(
						v3(0, -scale.y / 2),
						v3(0, 0, scale.z / 2)
						)
					)
				)
			);

		vertices.push( //5
			v3_add(
				pos,
				v3_add(
					v3(-scale.x / 2),
					v3_add(
						v3(0, -scale.y / 2),
						v3(0, 0, scale.z / 2)
						)
					)
				)
			);

		return (vertices);
	}

	/* returns list of cube vertices */
	function cube_vertices(pos, scale) {
		let vertices = [];
		vertices.push(
			v3_add(
				pos,
				v3_add(
					v3(0, 0, scale.z / 2),
					v3_add(
						v3(0, scale.y / 2),
						v3(-scale.x / 2)
						)
					)
				)
			);
		vertices.push(
			v3_add(
				pos,
				v3_add(
					v3(0, 0, -scale.z / 2),
					v3_add(
						v3(0, scale.y / 2),
						v3(-scale.x / 2)
						)
					)
				)
			);
		vertices.push(
			v3_add(
				pos,
				v3_add(
					v3(0, 0, -scale.z / 2),
					v3_add(
						v3(0, scale.y / 2),
						v3(scale.x / 2)
						)
					)
				)
			);
		vertices.push(
			v3_add(
				pos,
				v3_add(
					v3(0, 0, scale.z / 2),
					v3_add(
						v3(0, scale.y / 2),
						v3(scale.x / 2)
						)
					)
				)
			);
		/* down vertices */
		vertices.push(
			v3_add(
				pos,
				v3_add(
					v3(0, 0, scale.z / 2),
					v3_add(
						v3(0, -scale.y / 2),
						v3(-scale.x / 2)
						)
					)
				)
			);
		vertices.push(
			v3_add(
				pos,
				v3_add(
					v3(0, 0, -scale.z / 2),
					v3_add(
						v3(0, -scale.y / 2),
						v3(-scale.x / 2)
						)
					)
				)
			);
		vertices.push(
			v3_add(
				pos,
				v3_add(
					v3(0, 0, -scale.z / 2),
					v3_add(
						v3(0, -scale.y / 2),
						v3(scale.x / 2)
						)
					)
				)
			);
		vertices.push(
			v3_add(
				pos,
				v3_add(
					v3(0, 0, scale.z / 2),
					v3_add(
						v3(0, -scale.y / 2),
						v3(scale.x / 2)
						)
					)
				)
			);
		return (vertices);
	}

	/* returns list of cube vertices */
	function cylinder_vertices(pos, scale) {
		let vertices = [];
		// pos.x = cylinder diameter
		// pos.y = cylinder height
		// pos.z = level of detail
		let top = v3_add(pos, v3(0, -scale.y / 2));
		let first = v3_add(top, v3(scale.x / 2));
		console.log(`top: ${top}, first: ${first}`);
		for (var i = 0; i < scale.z; i++) {
			vertices.push(
				rotate_point(
					first,
					v3(0, i * Math.PI / (scale.z /2), 0),
					pos
				)
			);
		}
		let bottom = v3_add(pos, v3(0, scale.y / 2));
		let second = v3_add(bottom, v3(scale.x / 2));
		for (var i = 0; i < scale.z; i++) {
			vertices.push(
				rotate_point(
					second,
					v3(0, i * Math.PI / (scale.z /2), 0),
					pos
				)
			);
		}
		return (vertices);
	}

	function draw_cube_mappings(mappings, item) {
		connect_points(mappings[0], mappings[1], item);
		connect_points(mappings[1], mappings[2], item);
		connect_points(mappings[2], mappings[3], item);
		connect_points(mappings[3], mappings[0], item);

		connect_points(mappings[0], mappings[4], item);
		connect_points(mappings[1], mappings[5], item);
		connect_points(mappings[2], mappings[6], item);
		connect_points(mappings[3], mappings[7], item);

		connect_points(mappings[4], mappings[5], item);
		connect_points(mappings[5], mappings[6], item);
		connect_points(mappings[6], mappings[7], item);
		connect_points(mappings[7], mappings[4], item);
	}

	function draw_pyramid_mappings(mappings, item) {
		connect_points(mappings[0], mappings[1], item);
		connect_points(mappings[0], mappings[2], item);
		connect_points(mappings[0], mappings[3], item);
		connect_points(mappings[0], mappings[4], item);

		connect_points(mappings[1], mappings[2], item);
		connect_points(mappings[2], mappings[3], item);
		connect_points(mappings[3], mappings[4], item);
		connect_points(mappings[4], mappings[1], item);
	}

	function draw_sphere_mappings(mappings, item) {
		/*for (var i = 0; i < mappings.length - 1; i++) {
			connect_points(mappings[i], mappings[i + 1]);
		}*/
		let top_point = mappings[mappings.length - 2];
		let bottom_point = mappings[mappings.length - 1];
		for (let i = 0; i < item.scale.y; i++) {
			connect_points(top_point, mappings[i * item.scale.z], item);
			connect_points(bottom_point, mappings[i * item.scale.z + item.scale.z - 1], item);
			for (var j = 0; j < item.scale.z - 1; j++) {
				connect_points(mappings[i * item.scale.z + j], mappings[i * item.scale.z + j + 1], item);
			}
		}
	}

	function draw_cylinder_mappings(mappings, item) {
		for (let i = 0; i < mappings.length / 2 - 1; i++) {
			connect_points(mappings[i], mappings[i + 1], item);
		}
		connect_points(mappings[mappings.length/2 - 1], mappings[0], item);
		for (let i = mappings.length / 2; i < mappings.length- 1; i++) {
			connect_points(mappings[i], mappings[i + 1], item);
		}
		connect_points(mappings[mappings.length - 1], mappings[mappings.length/2], item);
		for (let i = 0; i < mappings.length / 2; i++) {
			connect_points(mappings[i], mappings[i + mappings.length / 2], item);
		}
	}


	function move_item(item, pos) {
		item.pos = v3_add(item.pos, pos);
		for (let i = 0; i < item.vertices.length; i++) {
			item.vertices[i] = v3_add(item.vertices[i], pos);
		}
	}

	function rotate_item(item, rot) {
		for (let i = 0; i < item.vertices.length; i++) {
			item.vertices[i] = rotate_point(item.vertices[i], rot, item.pos);
		}
		item.rot = v3_add(item.rot, rot);
	}

	function scale_item(item, scale) {
		let rot_backup = v3(item.rot.x, item.rot.y, item.rot.z);
		rotate_item(item, v3_invert(item.rot));
		item.scale = v3(scale.x, scale.y, scale.z);
		item.vertices = item.vertex_func(item.pos, item.scale);
		rotate_item(item, rot_backup);
	}

	function outline_item(item) {
		let mappings = [];
		for (var i = 0; i < item.vertices.length; i++) {
			//console.log(i + 1);
			//mappings.push(map_canvas_to_physical(project_point(item.vertices[i])));
			let mapping = map_point_to_physical(camera, project_point(item.vertices[i], camera), htmlcanvas.width, htmlcanvas.height);
			console.log(`pushing mapping: ${mapping}`);
			mappings.push(mapping);
		}
		item.draw_mapping_func(mappings, item);
	}
	
	let cube = new Item(ObjectType.Cube, v3(-0.5, 0, -5), v3(1, 1, 1), v3(), PINK, cube_vertices, draw_cube_mappings);
	//add_item(cube);

	let cube2 = new Item(ObjectType.Cube, v3(1, 0, -5), v3(1, 1, 1), v3(), BLUE, cube_vertices, draw_cube_mappings);
	//add_item(cube2);

	let pyramid = new Item(ObjectType.Pyramid, v3(1, 0, -3), v3(1, 1, 1), v3(-0.45999999999999863, 1.080000000000001, 4.160000000000001), BLUE, pyramid_vertices, draw_pyramid_mappings);
	//add_item(pyramid);

	let sphere = new Item(ObjectType.Sphere, v3(-3, 0, -5), v3(1, 8, 4), v3(), RED, sphere_vertices, draw_sphere_mappings);
	

	let sphere2 = new Item(ObjectType.Sphere, v3(0, 0, -5), v3(1, 8, 4), v3(), GREEN, sphere_vertices, draw_sphere_mappings);
	

	let sphere3 = new Item(ObjectType.Sphere, v3(3, 0, -5), v3(1, 8, 4), v3(), BLUE, sphere_vertices, draw_sphere_mappings);
	

	//add_item(sphere);
	//add_item(sphere2);
	//add_item(sphere3);

	let cylinder = new Item(ObjectType.Cylinder, v3(0, 0, -5), v3(1, 2, 10), v3(0, 1), GREEN, cylinder_vertices, draw_cylinder_mappings);
	add_item(cylinder);

	var shift_pressed = false;
	document.addEventListener('keydown', (event) => {
		if (event.key == 'Shift') {
			shift_pressed = true;
		}
	});
	document.addEventListener('keyup', (event) => {
		if (event.key == 'Shift') {
			shift_pressed = false;
		}
	});

	
	document.addEventListener('keydown', (event) => {
		if (event.key == '1') {
			draw();
		} else if (event.key == 'w') {
			camera.move(Direction.Forward, 0.1);
			draw();
		} else if (event.key == 's') {
			camera.move(Direction.Backward, 0.1);
			draw();
		} else if (event.key == 'a') {
			camera.move(Direction.Left, 0.1);
			draw();
		} else if (event.key == 'd') {
			camera.move(Direction.Right, 0.1);
			draw();
		} else if (event.key == 'Shift') {
			camera.move(Direction.Down, 0.1);
			draw();
		} else if (event.key == ' ') {
			camera.move(Direction.Up, 0.1);
			draw();
		} else if (event.key == 'ArrowRight') {
			camera.rotate(Direction.Right, 0.1);
			draw();
		} else if (event.key == 'ArrowLeft') {
			camera.rotate(Direction.Left, 0.1);
			draw();
		} else if (event.key == 'ArrowUp') {
			camera.rotate(Direction.Up, 0.1);
			draw();
		} else if (event.key == 'ArrowDown') {
			camera.rotate(Direction.Down, 0.1);
			draw();
		} else if (event.key == 'D') {
			debug_toggle = !debug_toggle;
			draw();
		} else {
			console.log(event);
		}
	});

	document.addEventListener('DOMContentLoaded', (event) => {
	  	draw();
	  	animation_interval = setInterval(animate, 25);
	});

	
	/////////////////////////////////

	// when the document is loaded, setup the listeners for the two canvas elements
    document.addEventListener('DOMContentLoaded', function () {
	    setupPointerLock();
	});


    // Configure all the pointer lock stuff
    function setupPointerLock() {

        // register the callback when a pointerlock event occurs
        document.addEventListener('pointerlockchange', changeCallback, false);
        document.addEventListener('mozpointerlockchange', changeCallback, false);
        document.addEventListener('webkitpointerlockchange', changeCallback, false);

        // when element is clicked, we're going to request a
        // pointerlock
        htmlcanvas.addEventListener('click', function () {
		    var requestPointerLock = htmlcanvas.requestPointerLock || htmlcanvas.mozRequestPointerLock || htmlcanvas.webkitRequestPointerLock;

		    // Ask the browser to lock the pointer
		    if (requestPointerLock) {
		        htmlcanvas.requestPointerLock();
		    }
		});


    }


    // called when the pointer lock has changed. Here we check whether the
    // pointerlock was initiated on the element we want.
    function changeCallback(e) {
        if (document.pointerLockElement === htmlcanvas ||
                document.mozPointerLockElement === htmlcanvas ||
                document.webkitPointerLockElement === htmlcanvas) {

            // we've got a pointerlock for our element, add a mouselistener
            document.addEventListener("mousemove", moveCallback, false);
            mouse_grabbed = true;
        } else {

            // pointer lock is no longer active, remove the callback
            document.removeEventListener("mousemove", moveCallback, false);
            mouse_grabbed = false;
            // and reset the entry coordinates
            entryCoordinates = {x:-1, y:-1};
        }
    };


    // handles an event on the canvas for the pointerlock example
    var entryCoordinates = {x:-1, y:-1};
    function moveCallback(e) {

        // if we enter this for the first time, get the initial position
        if (entryCoordinates.x == -1) {
            entryCoordinates = getPosition(htmlcanvas, e);
        }


        //get a reference to the canvas
        var movementX = e.movementX ||
                e.mozMovementX ||
                e.webkitMovementX ||
                0;

        var movementY = e.movementY ||
                e.mozMovementY ||
                e.webkitMovementY ||
                0;


        // calculate the new coordinates where we should draw the ship
        entryCoordinates.x = entryCoordinates.x + movementX;
        entryCoordinates.y = entryCoordinates.y + movementY;

        if (entryCoordinates.x > htmlcanvas.offsetWidth -65) {
            entryCoordinates.x = htmlcanvas.offsetWidth -65;
        } else if (entryCoordinates.x < 0) {
            entryCoordinates.x = 0;
        }

        if (entryCoordinates.y > htmlcanvas.offsetHeight - 85) {
            entryCoordinates.y = htmlcanvas.offsetHeight - 85;
        } else if (entryCoordinates.y < 0) {
            entryCoordinates.y = 0;
        }

        // determine the direction
        var direction = 0;
        if (movementX > 0) {
            direction = 1;
        } else if (movementX < 0) {
            direction = -1;
        }

        // clear and render the spaceship
        //ctx.clearRect(0,0,400,400);
        //generateStars(ctx);
        //showShip(entryCoordinates.x, entryCoordinates.y, direction,ctx);
        let coor = `entryCoordinates: (${entryCoordinates.x} ; ${entryCoordinates.y}), movement: (${movementX} ; ${movementY})`;
		document.getElementById("coords").innerHTML = coor;

		camera.rotate(Direction.Up, movementY / -100);
		camera.rotate(Direction.Right, movementX / 100);
		draw();
    }

    // Returns a position based on a mouseevent on a canvas. Based on code
    // from here: http://miloq.blogspot.nl/2011/05/coordinates-mouse-click-canvas.html
    function getPosition(canvas, event) {
        var x = new Number();
        var y = new Number();

        if (event.x != undefined && event.y != undefined) {
            x = event.x;
            y = event.y;
        }
        else // Firefox method to get the position
        {
            x = event.clientX + document.body.scrollLeft +
                    document.documentElement.scrollLeft;
            y = event.clientY + document.body.scrollTop +
                    document.documentElement.scrollTop;
        }

        x -= canvas.offsetLeft;
        y -= canvas.offsetTop;

        return {x:x, y:y};
    }

	/////////////////////////////////


	var prev_mouse_x = 0;//htmlcanvas.width / 2;
	var prev_mouse_y = 0;
	htmlcanvas.addEventListener("mousemove", (event) => {
		let x = event.offsetX;
		let y = event.offsetY;
		//let coor = "Coordinates: (" + x + " ; " + y + ")";
		//document.getElementById("coords").innerHTML = coor;

		/*if (mouse_grabbed) {
			camera.rotate(Direction.Up, (prev_mouse_y - event.clientY) / 1000);
			camera.rotate(Direction.Right, (prev_mouse_x - event.clientX) / -1000);
			prev_mouse_y = event.clientY;
			prev_mouse_x = event.clientX;
			console.log('X: ' + event.clientX);
    		console.log('Y: ' + event.clientY);
			draw();
		}*/
	});

	function toggleAnimation(checkbox) {
        rotate_items_toggle = checkbox.checked;
    }




    /////////////////
    //raytracing
    function gen_rays(camera, resolution) {
    	res = [];
    	let x_axis = v3_norm(camera.getAB());
    	let y_axis = v3_norm(camera.getAC());
    	for (var i = 0; i < camera.canvas_width; i += resolution) {
    		for (var j = 0; j < camera.canvas_height; j += resolution) {
    			let pt = v3_add(v3_add(camera.A, v3_scale(x_axis, i)), v3_scale(y_axis, j));
    			res.push(new Line(camera.eye, pt));
    		}
    	}
    	return (res);
    }

    /* https://hugi.scene.org/online/hugi24/coding%20graphics%20chris%20dragan%20raytracing%20shapes.htm */
    function intersect_ray_plane(ray, plane) {
    	/* ray direction */
    	let D = v3_norm(v3_sub(ray.p2, ray.p1));
    	/* O - C (o = ray origin, c = point on the plane) */
    	let X = v3_sub(ray.p1, plane.p1);
    	let N = plane.getNormal();
    	let d_v = v3_dot(D, N);
    	if (d_v == 0) {
    		return ([]);
    	}
    	let x_v = v3_dot(X, N);
    	let sign = 1;
    	if (!same_sign(d_v, x_v)) {
    		sign = -1;
    	}
    	let t = sign * x_v / d_v;
    	return ([v3_add(ray.p1, v3_scale(D, t))]);
    }
    function ray_plane_normal(ray, plane) {
    	let D = v3_norm(v3_sub(ray.p2, ray.p1));
    	let N = plane.getNormal();
    	let d_v = v3_dot(D, N);
    	if (d_v > 0) {
    		return (N);
    	} else {
    		return (v3_invert(N));
    	}
    }
    function intersect_ray_sphere(ray, sphere) {
    	let D = v3_norm(v3_sub(ray.p2, ray.p1));
    	let X = v3_sub(ray.p1, sphere.pos);
    	let a = v3_dot(D, D);
    	let b = 2 * v3_dot(D, X);
    	let r = sphere.scale.x / 2;
    	let c = v3_dot(X, X) - r*r;
    	let discriminant = b * b - 4 * a * c;
    	if (discriminant < 0) {
    		return ([]);
    	} else if (discriminant == 0) {
    		return ([v3_add(ray.p1, v3_scale(D, (-b + Math.sqrt(discriminant)) / 2 * a))]);
    	} else {
    		return ([v3_add(ray.p1, v3_scale(D, (-b + Math.sqrt(discriminant)) / 2 * a)), v3_add(ray.p1, v3_scale(D, (-b - Math.sqrt(discriminant)) / 2 * a))]);
    	}
    }
    function point_sphere_normal(point, sphere) {
    	return (v3_norm(v3_sub(point, sphere.pos)));
    }
    function point_inside_square(s1, s2, s3, s4, point) {
    	let plane = new Plane(s1, s2, s3);
    	let norm = plane.getNormal();
    	let altitudeComponent = Math.abs(v3_dot(v3_sub(point, s1), norm));
    	if (altitudeComponent >= TOLERANCE) {
    		return (false);
    	}
		if (!same_side_of_line(new Line(s1, s2), s3, point)) {
			return (false);
		}
		if (!same_side_of_line(new Line(s2, s3), s1, point)) {
			return (false);
		}
		if (!same_side_of_line(new Line(s3, s4), s1, point)) {
			return (false);
		}
		if (!same_side_of_line(new Line(s4, s1), s3, point)) {
			return (false);
		}
		return (true);
    }
    function intersect_ray_cube(ray, cube) {
    	let res = [];
    	/* checking intersection with each of 6 planes */
    	/* plane 1 = [0 - 3] ("roof") */
    	let plane = new Plane(cube.vertices[0], cube.vertices[1], cube.vertices[2]);
    	let ints = intersect_ray_plane(ray, plane);
    	if (ints.length > 0) {
    		if (point_inside_square(cube.vertices[0], cube.vertices[1], cube.vertices[2], cube.vertices[3], ints[0])) {
    			res.push(ints[0]);
    		}
    	}

    	plane = new Plane(cube.vertices[1], cube.vertices[2], cube.vertices[6]);
    	ints = intersect_ray_plane(ray, plane);
    	if (ints.length > 0) {
    		if (point_inside_square(cube.vertices[1], cube.vertices[2], cube.vertices[6], cube.vertices[5], ints[0])) {
    			res.push(ints[0]);
    		}
    	}
    	plane = new Plane(cube.vertices[2], cube.vertices[3], cube.vertices[7]);
    	ints = intersect_ray_plane(ray, plane);
    	if (ints.length > 0) {
    		if (point_inside_square(cube.vertices[2], cube.vertices[3], cube.vertices[7], cube.vertices[6], ints[0])) {
    			res.push(ints[0]);
    		}
    	}
    	plane = new Plane(cube.vertices[0], cube.vertices[3], cube.vertices[7]);
    	ints = intersect_ray_plane(ray, plane);
    	if (ints.length > 0) {
    		if (point_inside_square(cube.vertices[0], cube.vertices[3], cube.vertices[7], cube.vertices[4], ints[0])) {
    			res.push(ints[0]);
    		}
    	}
    	plane = new Plane(cube.vertices[0], cube.vertices[1], cube.vertices[5]);
    	ints = intersect_ray_plane(ray, plane);
    	if (ints.length > 0) {
    		if (point_inside_square(cube.vertices[0], cube.vertices[1], cube.vertices[5], cube.vertices[4], ints[0])) {
    			res.push(ints[0]);
    		}
    	}
    	plane = new Plane(cube.vertices[7], cube.vertices[6], cube.vertices[5]);
    	ints = intersect_ray_plane(ray, plane);
    	if (ints.length > 0) {
    		if (point_inside_square(cube.vertices[7], cube.vertices[6], cube.vertices[5], cube.vertices[4], ints[0])) {
    			res.push(ints[0]);
    		}
    	}
    	return (res);
    }
    function point_inside_triangle(s1, s2, s3, point) {
    	let plane = new Plane(s1, s2, s3);
    	let norm = plane.getNormal();
    	let altitudeComponent = Math.abs(v3_dot(v3_sub(point, s1), norm));
    	if (altitudeComponent >= TOLERANCE) {
    		return (false);
    	}
		if (!same_side_of_line(new Line(s1, s2), s3, point)) {
			return (false);
		}
		if (!same_side_of_line(new Line(s1, s3), s2, point)) {
			return (false);
		}
		if (!same_side_of_line(new Line(s2, s3), s1, point)) {
			return (false);
		}
		return (true);
    }
    function intersect_ray_pyramid(ray, pyramid) {
    	let res = [];
    	
    	let plane = new Plane(pyramid.vertices[1], pyramid.vertices[2], pyramid.vertices[3]);
    	let ints = intersect_ray_plane(ray, plane);
    	if (ints.length > 0) {
    		if (point_inside_square(pyramid.vertices[1], pyramid.vertices[2], pyramid.vertices[3], pyramid.vertices[4], ints[0])) {
    			res.push(ints[0]);
    		}
    	}
    	plane = new Plane(pyramid.vertices[0], pyramid.vertices[1], pyramid.vertices[4]);
    	ints = intersect_ray_plane(ray, plane);
    	if (ints.length > 0) {
    		if (point_inside_triangle(pyramid.vertices[0], pyramid.vertices[1], pyramid.vertices[4], ints[0])) {
    			res.push(ints[0]);
    		}
    	}
    	plane = new Plane(pyramid.vertices[0], pyramid.vertices[1], pyramid.vertices[2]);
    	ints = intersect_ray_plane(ray, plane);
    	if (ints.length > 0) {
    		if (point_inside_triangle(pyramid.vertices[0], pyramid.vertices[1], pyramid.vertices[2], ints[0])) {
    			res.push(ints[0]);
    		}
    	}
    	plane = new Plane(pyramid.vertices[0], pyramid.vertices[2], pyramid.vertices[3]);
    	ints = intersect_ray_plane(ray, plane);
    	if (ints.length > 0) {
    		if (point_inside_triangle(pyramid.vertices[0], pyramid.vertices[2], pyramid.vertices[3], ints[0])) {
    			res.push(ints[0]);
    		}
    	}
    	plane = new Plane(pyramid.vertices[0], pyramid.vertices[3], pyramid.vertices[4]);
    	ints = intersect_ray_plane(ray, plane);
    	if (ints.length > 0) {
    		if (point_inside_triangle(pyramid.vertices[0], pyramid.vertices[3], pyramid.vertices[4], ints[0])) {
    			res.push(ints[0]);
    		}
    	}
    	return (res);
    }
    function intersect_ray_cylinder(ray, cylinder) {
    	let res = [];
    	let C = v3_add(cylinder.pos, v3_scale(v3_norm(cylinder.rot), cylinder.scale.y / 2)); // top of the cylinder
    	let V = v3_invert(v3_norm(cylinder.rot)); // axis of the cylinder going from the point C to the bottom
    	let r = cylinder.scale.x / 2;
    	let L = v3_add(C, v3_scale(V, cylinder.scale.y)); // end cap of the cylinder

    	let D = v3_norm(v3_sub(ray.p2, ray.p1));
    	let X = v3_sub(ray.p1, C);

    	/*
			a   = D|D - (D|V)^2
			b/2 = D|X - (D|V)*(X|V)
			c   = X|X - (X|V)^2 - r*r
    	*/
    	let a = v3_dot(D, D) - Math.pow(v3_dot(D, V), 2);
    	let b = 2 * (v3_dot(D, X) - v3_dot(D, V) * v3_dot(X, V));
    	let c = v3_dot(X, X) - Math.pow(v3_dot(X, V), 2) - r * r;

    	let discriminant = b * b - 4 * a * c;
    	if (discriminant < 0) {
    		return ([]);
    	} else if (discriminant == 0) {
    		return ([v3_add(ray.p1, v3_scale(D, (-b + Math.sqrt(discriminant)) / 2 * a))]);
    	} else {
    		return ([v3_add(ray.p1, v3_scale(D, (-b + Math.sqrt(discriminant)) / 2 * a)), v3_add(ray.p1, v3_scale(D, (-b - Math.sqrt(discriminant)) / 2 * a))]);
    	}
    }
    function ray_intersection(ray, object) {
    	if (object.type == ObjectType.Plane) {
    		return (intersect_ray_plane(ray, object));
    	} else if (object.type == ObjectType.Sphere) {
    		return (intersect_ray_sphere(ray, object));
    	} else if (object.type == ObjectType.Cube) {
    		return (intersect_ray_cube(ray, object));
    	} else if (object.type == ObjectType.Pyramid) {
    		return (intersect_ray_pyramid(ray, object));
    	} else if (object.type == ObjectType.Cylinder) {
    		return (intersect_ray_cylinder(ray, object));
    	}
    	return ([]);
    }


    function set_cam_pos() {
    	camera.A = v3(2.156, 0.990, -4.029);
    	camera.B = v3(2.117, 0.990, -6.029);
    	camera.C = v3(2.176, -1.010, -4.030);
    	camera.eye = v3(3.146, -0.000, -5.049);
    	draw();
	}
    var lights = [];
    var debugg = null;
    function raytrace() {
    	debugg = [];
    	let first_drawn = true;
    	console.log("raytracing...");
    	let rays = gen_rays(camera, parseFloat(document.getElementById('rt_precision').value));

    	//rays.unshift(new Line(camera.eye, items[0].vertices[0]));
    	console.log(rays.length)
    	console.log(rays);
    	for (var i = 0; i < rays.length; i++) {
    		//draw_vect(map_point_to_physical(camera, rays[i].p2, htmlcanvas.width, htmlcanvas.height), 'black', 2, 6);
    		let intersections = [];
    		for (var j = 0; j < items.length; j++) {
    			let ints = ray_intersection(rays[i], items[j]);
    			for (var k = 0; k < ints.length; k++) {
    				intersections.push([rays[i].p2,
    									v3_len(v3_sub(ints[k], camera.eye)),
    									items[j].color]);
    				debugg.push([rays[i].p2, i]);
    				if (debugg.length == 1) {
    					console.log(`first i is: ${i}`);
    				}
    			}
    		}
    		if (intersections.length > 0) {
    			let closest_index = 0;
    			let closest_val = intersections[0][1];
    			for (var l = 0; l < intersections.length; l++) {
    				if (intersections[l][1] < closest_val) {
    					closest_index = l;
    					closest_val = intersections[l][1];
    				}
    			}
    			let le_point = map_point_to_physical(camera, intersections[closest_index][0], htmlcanvas.width, htmlcanvas.height);
    			let color = rgbToHexV3(intersections[closest_index][2]);
    			let width = 0.5;
    			if (!first_drawn) {
    				color = 'red';
    				width = 2;
    				first_drawn = true;
    				console.log(`drawing first point, unmapped: ${intersections[closest_index][0]}, mapped: ${le_point}`);
    			}
    			draw_circle(le_point.x, le_point.y, 1, color, width);
    		}
    	}
    	console.log("done!");
    	console.log(debugg);
    	console.log(`first hitting ray: ${debugg[0][0]}`);
    	console.log(`it intersects with the cube at ${ray_intersection(new Line(camera.eye, debugg[0][0]), items[0])[0]}`);
    }
</script>

</body></html>
